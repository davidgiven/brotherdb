;INCLUDES CODE FROM ANDY, JAMES, and BROTHER
;Includes code from Z80_Assembly_Language_Subroutines_1983.pdf Leventhal Saville 
; write the header

; org 0  ; Comment this out for normal binary
;jp emulator_vector  ; Comment this out for normal binary

org 5000h
db $8F, $c1, $01, $01, $00, $00, $42, $52

FALSE:  EQU     0
TRUE:   EQU     -1
         .ORG   5008h   
;         nop  ;I don't think I need these nops, I forgot why I put them here..
 ;        nop  ;it was some kind of diagnostic test.
  ;       nop
   ;      nop
    ;     nop
     ;    nop
         JP   APL_START   

;DEBUG:    EQU   FALSE
DEBUG:    EQU   FALSE

; The FEEDER is a debugging / scripting tool.
;It scripts Tinybasic separately from other stuff, change later...
FEED:     EQU   FALSE   
FEEDDEBUG:   EQU   TRUE   
FEEDER_CHIN:   
.if DEBUG = FALSE  ; if I'm debugging, don't differentiate between the two feeder pointers
   DW   SCRIPT1  
.endif
FEEDER_TINYBASIC:   DW   SCRIPT2   
SCRIPT1:   DB   "t\r"   
SCRIPT2:   DB   "10 FOR N = 1 TO 10\r20 NEXT N\rLIST\rGIBBERISH\r",0   



;SOME CONSTANTS FROM NASCOM BASIC.
;==================================================================================
; The updates to the original BASIC within this file are copyright Grant Searle
;
; You have permission to use this for NON COMMERCIAL USE ONLY
; If you wish to use it elsewhere, please include an acknowledgement to myself.
;
; http://searle.hostei.com/grant/index.html
;
; eMail: home.micros01@btinternet.com
;
; If the above don't work, please perform an Internet search to see if I have
; updated the web page hosting service.
;
;==================================================================================

; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
; the original ROM code (checksum A934H). PA

; GENERAL EQUATES


CTRLC:    EQU    03H             ; Control "C"
CTRLG:    EQU    07H             ; Control "G"
BKSP:    EQU    08H             ; Back space
;BS:    EQU    08H             ; Back space  JC added
LF:      EQU    0AH             ; Line feed
CS:      EQU    0CH             ; Clear screen
CR:      EQU    0DH             ; Carriage return
CTRLO:    EQU    0FH             ; Control "O"
CTRLQ:    EQU	11H             ; Control "Q"
CTRLR:    EQU    12H             ; Control "R"
CTRLS:    EQU    13H             ; Control "S"
CTRLU:    EQU    15H             ; Control "U"
ESC:     EQU    1BH             ; Escape
DEL:     EQU    7FH             ; Delete

; BASIC WORK SPACE LOCATIONS

;    WRKSPC:  EQU    8000H           ; <<<< BASIC Work space ** Rx buffer & Tx buffer located from 8000H **
.if DEBUG=TRUE
WRKSPC:  EQU    8000H           ; <<<< BASIC Work space ** Rx buffer & Tx buffer located from 8000H **
.else
; JC REDEFINING WRKSPC
WRKSPC:  EQU    ENDEND
.endif

USR:     EQU    WRKSPC+3H       ; "USR (x)" jump
OUTSUB:  EQU    WRKSPC+6H       ; "OUT p,n"  ;JC: On HD64180 this is not called
OTPORT:  EQU    WRKSPC+7H       ; Port (p)
DIVSUP:  EQU    WRKSPC+9H       ; Division support routine
DIV1:    EQU    WRKSPC+0AH      ; <- Values
DIV2:    EQU    WRKSPC+0EH      ; <-   to
DIV3:    EQU    WRKSPC+12H      ; <-   be
DIV4:    EQU    WRKSPC+15H      ; <-inserted
SEED:    EQU    WRKSPC+17H      ; Random number seed
LSTRND:  EQU    WRKSPC+3AH      ; Last random number
INPSUB:  EQU    WRKSPC+3EH      ; #INP (x)" Routine   ;JC: On HD64180 this is not called.
INPORT:  EQU    WRKSPC+3FH      ; PORT (x)
NULLS:    EQU    WRKSPC+41H      ; Number of nulls
LWIDTH:  EQU    WRKSPC+42H      ; Terminal width
COMMAN:  EQU    WRKSPC+43H      ; Width for commas
NULFLG:  EQU    WRKSPC+44H      ; Null after input byte flag
CTLOFG:  EQU    WRKSPC+45H      ; Control "O" flag
LINESC:  EQU    WRKSPC+46H      ; Lines counter
LINESN:  EQU    WRKSPC+48H      ; Lines number
CHKSUM:  EQU    WRKSPC+4AH      ; Array load/save check sum
NMIFLG:  EQU    WRKSPC+4CH      ; Flag for NMI break routine
BRKFLG:  EQU    WRKSPC+4DH      ; Break flag
RINPUT:  EQU    WRKSPC+4EH      ; Input reflection
POINT:    EQU    WRKSPC+51H      ; "POINT" reflection (unused)
PSET:    EQU    WRKSPC+54H      ; "SET"   reflection
RESET:    EQU    WRKSPC+57H      ; "RESET" reflection
STRSPC:  EQU    WRKSPC+5AH      ; Bottom of string space
LINEAT:  EQU    WRKSPC+5CH      ; Current line number
BASTXT:  EQU    WRKSPC+5EH      ; Pointer to start of program
BUFFER:  EQU    WRKSPC+61H      ; Input buffer
STACK:    EQU    WRKSPC+66H      ; Initial stack
CURPOS:  EQU    WRKSPC+0ABH     ; <<<< Character position on line ** Top of TEMPSTACK **
LCRFLG:  EQU    WRKSPC+0ACH     ; Locate/Create flag
TYPE:    EQU    WRKSPC+0ADH     ; Data type flag
DATFLG:  EQU    WRKSPC+0AEH     ; Literal statement flag
LSTRAM:  EQU    WRKSPC+0AFH     ; Last available RAM
TMSTPT:  EQU    WRKSPC+0B1H     ; Temporary string pointer
TMSTPL:  EQU    WRKSPC+0B3H     ; Temporary string pool
TMPSTR:  EQU    WRKSPC+0BFH     ; Temporary string
STRBOT:  EQU    WRKSPC+0C3H     ; Bottom of string space
CUROPR:  EQU    WRKSPC+0C5H     ; Current operator in EVAL
LOOPST:  EQU    WRKSPC+0C7H     ; First statement of loop
DATLIN:  EQU    WRKSPC+0C9H     ; Line of current DATA item
FORFLG:  EQU    WRKSPC+0CBH     ; "FOR" loop flag
LSTBIN:  EQU    WRKSPC+0CCH     ; Last byte entered
READFG:  EQU    WRKSPC+0CDH     ; Read/Input flag
BRKLIN:  EQU    WRKSPC+0CEH     ; Line of break
NXTOPR:  EQU    WRKSPC+0D0H     ; Next operator in EVAL
ERRLIN:  EQU    WRKSPC+0D2H     ; Line of error
CONTAD:  EQU    WRKSPC+0D4H     ; Where to CONTinue
PROGND:  EQU    WRKSPC+0D6H     ; End of program
VAREND:  EQU    WRKSPC+0D8H     ; End of variables
ARREND:  EQU    WRKSPC+0DAH     ; End of arrays
NXTDAT:  EQU    WRKSPC+0DCH     ; Next data item
FNRGNM:  EQU    WRKSPC+0DEH     ; Name of FN argument
FNARG:    EQU    WRKSPC+0E0H     ; FN argument value
FPREG:    EQU    WRKSPC+0E4H     ; Floating point register
FPEXP:    EQU    FPREG+3         ; Floating point exponent
SGNRES:  EQU    WRKSPC+0E8H     ; Sign of result
PBUFF:    EQU    WRKSPC+0E9H     ; Number print buffer
MULVAL:  EQU    WRKSPC+0F6H     ; Multiplier
PROGST:  EQU    WRKSPC+0F9H     ; Start of program text area
STLOOK:  EQU    WRKSPC+15DH     ; Start of memory test

; BASIC ERROR CODE VALUES

NF:      EQU    00H             ; NEXT without FOR
SN:      EQU    02H             ; Syntax error
RG:      EQU    04H             ; RETURN without GOSUB
OD:      EQU    06H             ; Out of DATA
FC:      EQU    08H             ; Function call error
OV:      EQU    0AH             ; Overflow
OM:      EQU    0CH             ; Out of memory
UL:      EQU    0EH             ; Undefined line number
BS:      EQU    10H             ; Bad subscript
DD:      EQU    12H             ; Re-DIMensioned array
DZ:      EQU    14H             ; Division by zero (/0)
ID:      EQU    16H             ; Illegal direct
TM:      EQU    18H             ; Type miss-match
OS:      EQU    1AH             ; Out of string space
LS:      EQU    1CH             ; String too long
ST:      EQU    1EH             ; String formula too complex
CN:      EQU    20H             ; Can't CONTinue
UF:      EQU    22H             ; UnDEFined FN function
MO:      EQU    24H             ; Missing operand
HX:      EQU    26H             ; HEX error
BN:      EQU    28H             ; BIN error

; ORG    0399H           ; <<<< Modified to allow for Z180 Tx/Rx interrupt & HexLoadr
;==============================================================


;CONSTANTS from http://www.hd64180-cpm.de/resources/180MACRO.LIB
;ASCI REGISTERS
CNTLA0:	EQU	00H
CNTLA1:	EQU	01H
CNTLB0:	EQU	02H
CNTLB1:	EQU	03H
STAT0:	EQU	04H
STAT1:	EQU	05H
TDR0:	EQU	06H
TDR1:	EQU	07H
RDR0:	EQU	08H
RDR1:	EQU	09H

in0a_STAT1:
    in0a STAT1
    ret
in0a_RDR1:
    in0a RDR1  ; THIS PRODUCED WRONG CODE when nested elsewhere, so making a subroutine
    ret
in0a_STAT0:
    in0a STAT0
    ret
in0a_RDR0:
    in0a RDR0
    ret


; JC HAD ISSUES USING THESE MACROS INSIDE A CONDITIONAL.  Don't do it in ASM80!
.macro in0a
.if DEBUG = FALSE
;    ld a,0 ;you would need this on HD64180 for in a,(00xx) page zero in
;    in a,%%1
    db 0EDh, 038h, %%1 ; EXTENDED INSTRUCTION HD64180 ZERO-PAGE I/O IN
.else
    nop ; Use this moment to supply a byte to serial input?
    nop ; IN0 a,(port)
.endif
.endm

.macro out0a
.if DEBUG = FALSE
    db 0EDh, 039h, %%1 ; EXTENDED INSTRUCTION HD64180 ZERO-PAGE I/O OUT
.else
    nop ; OUT0 (port),a
.endif
.endm

;.ent $   ; ENTRY POINT FOR DEBUGGING. Debug entry.
APL_START:
          LD   BC,0   ; GETTING THE STACK POINTER so I can restore it for exit
          LD   H,B   
          LD   L,B   ; HL=0 NOW
          ADD   HL,SP   ; HERE IS THE STACK ;this method is from TINY BASIC
          LD   (SP_STORED_ON_ENTRY),HL   
    jp apl_code_normal_start  ; NORMAL APL entry point is first ORG ($5000)+8
EXIT_APL:      
          LD   HL,(SP_STORED_ON_ENTRY)   
          LD   SP,HL   
          RET      
SP_STORED_ON_ENTRY:   DW   0   
    db "EMULATOR ONLY:"
emulator_vector:
    ld SP,0080h  ;Initialize stack pointer for the EMULATOR.  NOT for Brother hardware.
    call Call_Debugger

    ret
    db "NORMAL ENTRY:"
apl_code_normal_start:
;    ld   bc,Message
;    call ShowMessage
    call ConfigureSerial
          JP   startover   
JC_MENU:
.if DEBUG=FALSE
    db   "\r\nJC MENU. Single keypresses... no need for enter here.\r\n"   
	db "o z Z c C misc tests see source\r\n"   
	db "d=Debugger ?=inbuffer CTRL-C \r\n"   	
	db "t=TinyBASIC D=DUMPMEM f=FILLMEM(crash)\r\n"   
	db "i,I=I/ODUMP L=SetSerDelay R=Registers(notimp)\r\n"   
	db "X=EXIT!/reboot.  ESC usually kills.\r\n"   
.endif
    db "OK!\r\n"   
    db 0   
startover:
okprompt:
    ld de,buffer1  ; Get our buffer location
    ld (bufptr1),de ; zero the pointer to the current byte
    ld   hl,JC_Menu   
    call   write_string
loopecho:
    call chin
    ld b,a   

    cp "o"   ; "Hello Andy" and such, system call testing.
    JP   z,Do_Other_Testing   
    cp "O"   ; "Hello Andy" and such, system call testing.
    JP   z,Do_Other_Other_Testing   
    CP   "z"   ; TEST non-HD64180 instructions for reading I/O
    CALL   z,Test_Z80_In   ; it didn't work, dunno why
    CP   "Z"   ; TEST non-HD64180 instructions for writing I/O
    CALL   z,Test_Z80_Out   ; it didn't work, dunno why
    CP   "c"   ; TEST CHKIO_SURROGATE ISSUE
    JP   z,Test_CHKIO_SURROGATE_echo   
    CP   "C"   ; TEST CHKIO_SURROGATE ISSUE outer function
    JP   z,Test_CHKIO_echo   

    cp 'd'
    jp z,Call_Debugger
    cp '?'
    call z,printbuffer1
    cp 3
    jp z,startover
    cp 't'
    jp z,Call_TinyBasic
    cp 'D'
    jp z,DUMP_MEMORY
    cp 'f'
    jp z,FILL_MEMORY
    cp 'i'
    jp z,DUMP_IO0
    cp 'I'
    jp z,DUMP_IOxxxx 
    cp 13
    call z,parse1
    cp 10
    call z,parse1
    cp 'L' ; Send delay length
    jp z, SetShortDelayLength
    cp 'R' ; Dump registers
    jp z, DumpRegisters
    CP   "X"   ;uppercase X to exit this .APL
    JP   z,EXIT_APL   

    ld (de),a
    inc de ;Increment the buffer pointer
    ld a,(de) ; Check for 255 (buffer limit)
    cp 255
    jr nz,notfull1
    dec de ; if full, just back it up to the prev byte.
    ld a,BS ; output a backspace to indicate this to the user
    call MONOUT
notfull1:
    ld a,0
    ld (de),a  ; Null-terminate the commandline.
    ld (bufptr1),de

    ld a,b ; get the char back to echo it
    call MONOUT

    jr loopecho

; My variables for this little interface
firstbyte1:    defb 0
firstword1:  defw 0000
secondword1: defw 0000
state1:      defb 0
buffer1:      defs 256
bufend1:  defb 255
bufptr1    defw buffer1
addcommandlinechar: ; didn't finish this, it means nothing

SetShortDelayLength: ; JC: THis is not finished... 
 ; JC: I made it change a single byte, but the variable is a word.
 
    call chin
    cp 30
    jr c,doneSetDelay ;error not reported, don't set delay.
    cp 40 
    jr c,sub30
    sub 7 ; Turn 'A' into '0'+10 
sub30:
    sub 30
    ld b,a
    ;Multiply by 10; multiply by 8 first then add twice.
    rlc a
    rlc a
    rlc a; thre rotations = times 8
    and 0b11111000; clear the rotated low bits
    rlc b; twice b
    add a,b ; this should be our *10 number.  
    ld (ShortDelay_Length+1),a
doneSetDelay:
    call CRLF
    ld a,'='
    call MONOUT
    ld a,(ShortDelay_Length+1)
    call puthexbyte
    call CRLF
    jp okprompt

DumpRegisters:
          LD   BC,0   
          LD   H,B   
          LD   L,B   ; HL=0 NOW
          ADD   HL,SP   ; HERE IS THE STACK ;this method is from TINY BASIC
parse1:
    call CRLF
    ld hl,buffer1
    call write_string    
    ; I want to move the previous single-key options to here.
    ret

printbuffer1:
    call CRLF
    ld hl,buffer1
    call write_string    
    call CRLF
    ret
             ;JC MOVED THIS ROUTINE EARLIER as a diagnostic.
             ; The location didn"t matter, I still saw endless 04"s.
.align   32   
chkio_surrogate:  ;(equivalent to chin for TINY BASIC)
             ; =======================BEGIN FEEDER
             ; JC MAKING A STARTUP SCRIPT, USEFUL FOR DEBUGGING AND
             ; also possibly useful for the real thing.
             ; It pretends to be serial input.  Can enter a program, etc.
.if (FEED = TRUE) | ((DEBUG = TRUE)&(FEEDDEBUG=TRUE))   
          PUSH   HL   
          LD   HL,(FEEDER_TINYBASIC)   
          LD   a,(HL)   
          INC   HL   
          LD   (FEEDER_TINYBASIC),HL   
          OR   a   ; Check if zero, null-terminated script
          POP   HL   
          JR   z,End_feeding   
          RET      
.endif      
END_FEEDING:      
             ; =======================END FEEDER
.if DEBUG = FALSE   
             ; read a char from uart
;Return Zero if there isn't one.
             ;JC saw this function failing.  Now testing to see if
             ;this location will tolerate a plain chin call:
;        CALL   chin   ; JC to try removing this again
;        ret	
             ;END jc test 
;JC MARK FISH001 PROBLEMS:
    LD   a,0   
    call in0a_STAT1  ; The CALL here is because I had macro/conditional nesting issues
    and 10000000b
    ret z                   ;this wasn't working
    call in0a_RDR1  ; THIS PRODUCED WRONG CODE WHY ; The CALL here is because I had macro/conditional nesting issues
    CP   27   ; JC adding abort.
    JP   z,apl_code_normal_start   
    ret
.else ; DEBUG MODE
    ld a,0
    nop ; Use this moment to supply a byte to serial input?
    nop ; Use this moment to supply a byte to serial input?
    or a
    ret
.endif
.align   32   
Clear_ASCIs: ;MOVE this to Clear_ASCIs_actual for build.
Clear_ASCIs_actual:
;This is to clear any serial characters accidentally following the character choice.
; This is important for my terminal program which sends crlf when
;I enter lines for sending (Cutecom).  
    in0a     RDR1
    CALL   ShortDelay
    CALL   ShortDelay
    in0a     RDR1
    CALL   ShortDelay
    CALL   ShortDelay
    in0a     RDR1
    CALL   ShortDelay
    CALL   ShortDelay
    in0a     RDR1
    CALL   ShortDelay   
    CALL   ShortDelay   
Clear_ASCIs_debug:
    ret

Call_Debugger:
    call Clear_ASCIs
    call monitor_pre_start
    jp okprompt

Call_TinyBasic:
    call Clear_ASCIs
    call tinybasic_start
    jp okprompt

puthexword:  ;WORD in BC
    push AF
    push BC
    ld a,b
    and 0f0h ; First nybble ; not sure why this step is needed
    rrca
    rrca
    rrca
    rrca
    and 00fh
    call NASCII
    call MONOUT
    ld a,b
    and 0fh  ; Second nybble
    call NASCII
    call MONOUT
    ; SECOND BYTE:
    ld a,c
    and 0f0h ; First nybble ; not sure why this step is needed
    rrca
    rrca
    rrca
    rrca
    and 00fh
    call NASCII
    call MONOUT
    ld a,c
    and 0fh  ; Second nybble
    call NASCII
    call MONOUT
    pop BC
    pop AF
    ret
    
TEMP_BYTE_PUTHEX defs 1

puthexbyte:
    ld (TEMP_BYTE_PUTHEX),a
    and 0f0h ; First nybble
    rrca
    rrca
    rrca
    rrca
    and 00fh
    call NASCII
    call MONOUT
    ld a,(TEMP_BYTE_PUTHEX)
    and 0fh  ; Second nybble
    call NASCII
    call MONOUT
    ret

DUMPSTART: defw 0
DUMPtemp: defs 2
DUMP_MEMORY:
    ;At the moment this dumps ALL 64K OF MEMORY.  Starts at DUMPSTART.
    ;SET bottom and top
    ;Exchange SP and BC
    ;Store BC
    ;Exchange SP and BC
    ;Print out the SP
    ;Get PC
    ;Print out the PC somehow.  I think I did code for this!
; MARK THE BOTTOM OF THE STACK SO WE CAN SEE IT IN A HEX DUMP
    ld HL,0EFBEh   ;BEEF +
    push HL
    ld HL,0ADDEh   ;DEAD => DEADBEEF in hex dump marking stack
    push HL
    ld HL,'K!'
    push HL
    ld HL,'AC'
    push HL
    ld HL,'ST'
    push HL

    CALL DUMPMEM

    pop HL 
    pop HL 
    pop HL 
    pop HL 
    pop HL 
    jp okprompt
CHECK_SERIN1:      
          in0a    STAT1
          AND   10000000b   
          RET      
DUMPMEM:
    ;At the moment this dumps ALL 64K OF MEMORY.  Starts at DUMPSTART.
    ;Start at zero.  Maybe later I will have parameters.
    ld HL,(DUMPSTART)
    call Clear_ASCIs ; It was getting false characters because I hit return
      ; This just makes sure an initial spurious keypress 
      ; doesn't interrupt the hex dump.
DUMPMEM1:
    ld a,l
    and 01Fh
          JR   nz,sameline2   
dump_not_stopped1:    
          CALL   CRLF   ;Next line
          CALL   check_serin1   ; ANY KEY will stop the dump
          JP   nz,stoppeddump   
    ld bc,hl
    call puthexword
    ld a,':'
    call MONOUT
    ld a,' '
    call MONOUT
sameline2:      
    ld a,(HL)
    call puthexbyte
    inc HL
    ;Check for HL=0
    ld a,h
    or l
    or a ; It wasn't stopping before.  I don't know why.  Adding this to test JC
    jr nz,DUMPMEM1
stoppeddump:      
    ret

; This got reformatted when I lost code.
DUMP_IO0:
          CALL   Clear_ASCIs   ; ward off accidental keystrokes
DUMPIO0:      
          LD   HL,(DUMPSTART)   
          LD   a,l   
          AND   01Fh   
          JR   nz,sameline0   
          CALL   CRLF   ;Next line
          CALL   check_serin1   ; ANY KEY will stop the dump
          JP   nz,stoppeddump0   
          LD   bc,hl   
          CALL   puthexword   
          LD   a,":"   
          CALL   MONOUT   
          LD   a," "   
          CALL   MONOUT   
SAMELINE0:      
          LD   bc,hl   
             ;    ld b,h  ; need this on HD64180 for in a,(C); b is the high byte
          IN   a,(c)   
          CALL   puthexbyte   
          INC   HL   
             ;Check for L=0, just doing first page.
          LD   a,l   
          OR   a   ; Check to see if this is zero
          JR   nz,DUMPIO0   
STOPPEDDUMP0:      
          JP   okprompt   ; Return to James' menu
	  
DUMP_IOxxxx:
    ;This dumps ALL 64K OF I/O.  Starts at DUMPSTART which is probably 0.
    ld HL,(DUMPSTART)
    call Clear_ASCIs ;
DUMPIO1:
    ld a,l
    and 01Fh
    jr nz, sameline4

    call CRLF;Next line
          CALL   check_serin1   ; ANY KEY will stop the dump
          JP   nz,stoppeddump2   
    ld bc,hl
    call puthexword
    ld a,':'
    call MONOUT
    ld a,' '
    call MONOUT
sameline4:      
    ld bc,hl
    in a,(c)
    call puthexbyte
    inc HL
    ;Check for HL=0
    ld a,h
    or l
    or a 
    jr nz,DUMPIO1
stoppeddump2:      
    jp okprompt   ; Return to James' menu
    

FILL_MEMORY: ; SURE TO CRASH THE MACHINE.  Top down.
    CALL FILLMEM
    jp okprompt
FILLMEM:
    ;Start at $FFFF and work down.   Maybe later we can add parameters.
    ; This seems useless but I'm learning to write these loops.
    ld h,0
    ld l,h
FILLMEM1:
    dec HL
    ld a,l
    and 0FFh
    jr nz, notzero6
    ld a,CR
    call MONOUT
    ld a,LF
    call MONOUT
    ld bc,hl
    call puthexword
    ld a,':'
    call MONOUT
    call chin   ; WAIT FOR A KEYPRESS  This can be used to control the fill.
    ld a,' '
    call MONOUT
notzero6:
writethebyte:
    ld a,55h ; nice flavorful number
    ld (HL),a
    inc HL
    ;Check for HL=0
    ld a,h
    or l
    jr nz,FILLMEM1
    ret

;BROTHER MACROS:
;NAMING CONVENTION: 
; If calling RST, the macro will be named 
; RST[OFFSET]H_AA_BB and so on however registers are known to be required.
;SO for example the ClearScreen macro:
; RST10H_10_01_CLEARSCREEN calls RST 10h, with ld a,010 and ld b,001
; They may also be named with _getXX for returned responses in register XX
.macro RST10H_10_01_CLEARSCREEN
    ld b,001h
    ld a,010h
    rst 10h
.endm
.macro RST30H_05_04_getHL
	ld a,005h
	ld b,004h
	ld hl,00000h
	rst 30h	
.endm
.macro RST30H_04_03
	ld b,003h
	ld a,004h
	rst 30h	
.endm
.macro RST30H_01  ; Called before exiting?
    ld a,001h
	rst 30h	
.endm
.macro RST08H_05_GETKEY_retD_Cflag
	ld a,005h
	rst 8	
.endm


Do_Other_Other_Testing:
WAITFORKEY:
	push bc			;9023	c5 	. 
	push de			;9024	d5 	. 
	push hl			;9025	e5 	. 
;	ld a,005h		;9026	3e 05 	> . 
;	rst 8			;9028	cf 	. 
    RST08H_05_GETKEY_retD_Cflag
	ld a,d			;9029	7a 	z 
	pop hl			;902a	e1 	. 
	pop de			;902b	d1 	. 
	pop bc			;902c	c1 	. 
; CARRY FLAG?  If not...
	jr nc,WAITFORKEY ;l9023h		;902d	30 f4 	0 . 
;	cp 08fh		;902f	fe 8f 	. . 
; IS IT 08?
;	jr z,WAITFORSOMETHING ;l9023h		;9031	28 f0 	( . 
    call puthexbyte 
    jr WAITFORKEY
    
    
Do_Other_Testing:
    ld   bc,Message
    call ShowMessage
    call Delay
    
    ld hl, Message+3
    db 0EDh, 038h, 038h ;in0 a,(38h)
    ld b,a
    db 0EDh, 038h, 039h ;in0 a,(39h)
    ld c,a
    call MakeHexMessage
    db 0EDh, 038h, 03Ah ;in0 a,(3Ah)
    ld b,a
    ;db 0EDh, 038h, 036h ;in0 a,(36h)
    in0a 36h
    ld c,a
    call MakeHexMessage
    
    ld   bc,Message
    call ShowMessage
     ; JC trying to get out of here
     JP   okprompt   ; JC's OK prompt.  Not a total restart.
     call ResetAndExit
     ret  ; neither of these thing happen if I jump to the ok prompt

   ; My assembler won't take the new mnemonics.
OutSer0:  
    out0a (TDR0)
    ret
OutSer1:
    out0a (TDR1)
    ret

OUTBYTE: DEFS 1   ; storage byte to send

; THIS IS THE BYTE OUTPUT FUNCTION FOR
; THE NASCOM BASIC (and presumably monitor, wherever that is!)
MONOUT: ; MOVE THIS TO MONOUT_actual for BUILD:        
MONOUT_actual:
.if DEBUG = FALSE
        push af
        push bc ; I don't know, I am still having problems.  May not need this.
        push de
        ; BLOCKING as long as the ShortDelay
        CALL OutSer0           ; output a char
        CALL OutSer1           ; output a char
        call ShortDelay  ; Using a delay to prevent character loss when not polling TDRE
        pop de
        pop bc
        pop af
MONOUT_debug1: 
        ret
.else ; DEBUG MODE
    nop ; 
    nop ; Use this moment to recognize a byte of output
    ret
.endif

MONOUT_checkready:  ; This sends but checks TDRE to see if Transmit Data Register is Empty, rather than using a delay.
 ; THIS DOES NOT WORK ON BROTHER TYPEWRITERS WITH RXA PINS SHORTED TO HANDSHAKING.
        ; BLOCKING
        ld (OUTBYTE),a  ; store it
notready0:
        in0a    STAT0
        in0a    STAT0
        and 00000010b  ; poll TDRE (Transmit data register empty)
        jr  z, notready0
        ld a,(OUTBYTE)
        CALL OutSer0           ; output a char
notready1:
        in0a    STAT1
        in0a    STAT1
        and 00000010b  ; poll TDRE (Transmit data register empty)
        jr  z, notready1
        ld a,(OUTBYTE)
        CALL OutSer1           ; output a char
;        call ShortDelay  ; I was using a delay to prevent character loss when not polling TDRE
        ld a,(OUTBYTE); Make sure I didn't trash the byte, like in the delay?
                    ; that was stupid!
MONOUT_debug2: 
        ret

ShortDelay_Length: DEFW 90
ShortDelay:
    ;fine-tuning a delay for 9600 baud serial
    push af
    push bc
    ld a,255
    ld bc, (ShortDelay_Length) ; 20 was too short
    Outer2:
        nop
        nop
        nop
        dec bc                  ;Decrements BC
        ld a, b                 ;Copies B into A
        or c                    ;Bitwise OR of C with A (now, A = B | C)
    jp nz, Outer2            ;Jumps back to Outer: label if A is not zero
    pop bc
    pop af  
    ret                     ;Return from call to this subroutine
    
   

;JC wants to incorporate this kind of polling to make sure txrdy
;write_char:		ld	b,a			;store char
;write_char_loop:	in	a,(3)			;check if OK to send
;			and	001h			;check TxRDY bit
;			jp 	z,write_char_loop	;loop if not set
;			ld 	a,b			;get char back
;			out 	(2),a			;send to output
;			ret				;returns with char in a

MakeHexMessage:  ; PROVIDE hex value in BC.  
   ; Provide text buffer in hl
    push bc
; First byte
    ld a,b
    and 0f0h ; First nybble
    rrca
    rrca
    rrca
    rrca
    call NASCII
    ld (hl),a
    inc hl
    ld a,b
    and 0fh  ; Second nybble
    call NASCII
    ld (hl),a
    
    inc hl
; 2nd byte
    ld a,c
    and 0f0h ; Third nybble
    rrca
    rrca
    rrca
    rrca
    call NASCII
    ld (hl),a
    inc hl
    ld a,c
    and 0fh  ; Fourth nybble
    call NASCII
    ld (hl),a

    inc hl
    ld (hl),0FFh    
    ; Don't increment.  Could do multiple ops in sequence.
    pop bc
    ret
    
NASCII: ; Convert a Hex nybble to an ASCII character
    cp 10
    jr c,NAS1
    ADD a,7
NAS1:
    ADD a,'0'
    ret

ResetAndExit:
    ld      a,0eh
    rst     28h
    ld      a,06h
    rst     28h
    ld      a,01h
    rst     30h
ret

ConfigureSerial:
; Note, the prescaler is 111 (external clock) on reset.  
;This changes it to the fastest internal baud rate. 
; Clock rate is 12.27Mhz (Clock speed) / divisor for 001 = 12270000/320.
; It's 38343, close to 38400.
; My crystal is 12.27
; Trying a different divisor to get slower signal.
;
    ld a,0
 ;   ld b,a
 ;   ld c,a
    ld a,01100100b
    out0a CNTLA0    ;   out (CNTLA0),a
;    ld a,00000001b  ; 19200bps ; Didn't work for input.
    ld a,00000010b  ; 9600bps
;    ld a,00001110b  ; 150bps
    out0a CNTLB0    ;   out (CNTLB0),a
    
    ld a,01100100b
    out0a CNTLA1    ;    out (CNTLA1),a
    ld a,00000010b  ; 9600bps
;    ld a,00001010b  ; 2400bps
    out0a CNTLB1    ;    out (CNTLB1),a
    ret
    
TestSerial:
    ld de,0500h ; do it about 5*256 times or 1280 times
Loopserial:
    ld a,'T'
    call MONOUT
    ld a,'E'
    call MONOUT
    ld a,'S'
    call MONOUT
    ld a,'T'
    call MONOUT
    ld a,13
    call MONOUT
    call code_start
;    call COLD   ; call BASIC. 
    dec de
    jr Loopserial
    
exit1:    
    ret
 
ShowMessage:
    push    bc
    push    de
    push    hl
;    ld      bc,Message ; Take it as a parameter!
    call    ClearMessageBar
    call    GetBottomMenuPtr
    ld      a,(bc) ; Loading &0e into a
    ld      d,a ; d = &0e
    inc     bc ; points to: 00
    ld      a,(bc); Loads &00 into a
    ld      e,a ; Moves &00 to e
    inc     bc ; Point to &90
    push    de ; Puts 0e00 onto stack
    push    bc ; addr onto stack
    ld      de,0000h ; de reset to 0
Jbwd:
    inc     hl ; ???
    inc     bc ; moves to: &00
    ld      a,(bc) ; a is now &00
    cp      0ffh ; looking for ff (our terminator)
    jr      z,Jfwd          ; (+06h)
    ld      (hl),a ; hl
    inc     hl
    inc     de
    inc     de
    jr      Jbwd
Jfwd:
    pop     bc
    ld      a,(bc)
    cp      00h
    jr      z,FlushAndExit
    call    GetBottomMenuPtr
    ld      a,(bc)
; This loop inverts the text to be a yellow bar with black writing
; Start Invert
    ld      b,5bh ; 91
Again:
    ld      (hl),a
    inc     hl
    inc     hl
    djnz    Again    ;loops 91 times (cause of b)
; End Invert
    ld      de,00b6h
FlushAndExit:
    ld      c,e
    ld      b,d
    pop     hl
    call    FlushMenu ; or redraw?
    pop     hl
    pop     de
    pop     bc
ret     

ClearMessageBar:
    push    bc
    push    de
    push    hl
    call    GetBottomMenuPtr
    ex      de,hl
    call    GetBottomMenuPtr
    inc     de ; de is no +1 of hl
    ld      (hl),00h ; write 00 to hl
    ld      bc,0111h ; set max to 111
    ldir    ; Now loop, wiping everything
    pop     hl
    pop     de
    pop     bc
ret

GetBottomMenuPtr: ; loads ptr to hl
    push    af
    push    bc
    ld      a,05h
    ld      b,00h
             ;JC testing direct call instead of rst
             ;   rst     30h
          CALL   0030h   ;JC testing direct call instead of rst
    pop     bc
    pop     af
ret

FlushMenu:
    push    af
    push    de
    push    hl
    ex      de,hl
    call    GetBottomMenuPtr
    ld      a,13h
             ;JC testing direct call instead of rst
             ;    rst     10h
          CALL   0010h   ;JC testing direct call instead of rst
    pop     hl
    pop     de
    pop     af
ret

; Thanks to: http://www.paleotechnologist.net/?p=2589
; This will cause a ~10 sec or so delay (depending on clock speed)
Delay:
    ld bc, 100h            ;Loads BC with hex 100
    Outer1:
        ld de, 1000h            ;Loads DE with hex 1000
            Inner1:
                dec de                  ;Decrements DE
                ld a, d                 ;Copies D into A
                or e                    ;Bitwise OR of E with A (now, A = D | E)
            jp nz, Inner1            ;Jumps back to Inner: label if A is not zero
        dec bc                  ;Decrements BC
        ld a, b                 ;Copies B into A
        or c                    ;Bitwise OR of C with A (now, A = B | C)
    jp nz, Outer1            ;Jumps back to Outer: label if A is not zero
ret                     ;Return from call to this subroutine

; Not currently used, but will lock up the typewriter
; Used this before I found the Delay
InfiniLoop:
    ld  b, 00h
    ld  a,b
    cp  00h
jr  z,InfiniLoop

Message:
;    db $0d, $01, $71, $01 ; This came out underlined inverted, with -> arrow on left, not flashing
;    db $0c, $02, $62, $03 ; This came out underlined, noninverted, down-arrows at beginning, up one line from previous
;    db $08, $03, $53, $33 ;Looks like line 8?, underline, "3" at beginning, Inverted
;    db $01, $04, $53, 0 ;Underlined, 2nd line, inverted, not flashing.  Not aligned left, I'm thinking it moved over.   
;    db $0f, $05, $00, $00 ; This produced normal text. 
;    db $0f, $15, $FF, $00 ; This produced an inverted blinking underline with no text.
;    db $00, $00, $28 ; Top left, no special attributes apparent... noninverting, not flashing not underlined.  Cleared the line.  
;    db $00, $00, $44 ; This produced a cleared line.  Black text on black background?
;    db $00, $00, $BB ; Inverted, with flashing DOUBLE underline and flashing text.
;   ... I didn't notice the double underline before, but it may already have shown up.
;    ... Some of the underlines were higher.  
             ;db $00, $00, $0C ; Blank line across the top?
             ;db $00, $00, $1B ; Looks like double-underline inverted, not flashing
             ;I think some of the "no text" options may be hidden because of my 5500's character ROM!
             ; Maybe it will show differently on Andy's 2450?
             ; Going to check each attribute flag in sequence.
             ;db $00, $00, $01 ; Single underline, noninverted.
             ;db $00, $00, $02 ; Single underline, noninverted.
             ;db $00, $00, $04 ; Completely blank/invisible?
             ;db $00, $00, $08 ; Plain text, noniverted, no underline.
             ;db $00, $00, $10 ; Inverted text, no underline.
             ;db $00, $00, $20 ; Plain text, noninverted, no underline.
             ;db $00, $00, $40 ; Plain text
             ;db $00, $00, $80 ; Flashing plain text.
             ;db $00, $00, $0F ; Double underline, EMPTY/NO TEXT, noninverted, not flashing.
          defb  $00,$00,$80   ; testing...
          defb  "Hello"   
          defb  $00   ; spaces are nulls for message bar
          defb  "Andy!"   
          defb  $ff   ; String terminator
Message2:
    db $0e, $00, $90, $00 ; Message bar, yes. Offset of some sort
    db "This_is_doing_something"
    db $00 ; spaces are nulls for message bar
    db "Different!"
    db $ff ; String terminator    
    

; JC string output Function.  Prints the null-terminated string after the CALL.
strout:
    ex	(sp),hl
strout1:	ld	a,(hl)
	inc	hl
	or	a
	jr	z,strout2
	call MONOUT  
	jr	strout
strout2:	
    ex	(sp),hl
	ret
	
; STUFF GOT REFORMATTED FROM VERSION LOSS

             ; read a char from serial 1.  Trouble with serial 0.
             ;Blocking.  Waits until a character arrives.
             ; JC CHANGING TO SINGLE SERIAL.
chin:
chin_actual:
             ; =======================BEGIN FEEDER
             ; JC MAKING A STARTUP SCRIPT, USEFUL FOR DEBUGGING AND
             ; also possibly useful for the real thing.
             ; It pretends to be serial input.  Can enter a program, etc.
          IF   (FEED = TRUE) | ((DEBUG = TRUE)&(FEEDDEBUG=TRUE))   
          PUSH   HL   
          LD   HL,(FEEDER_CHIN)   
          LD   a,(HL)   
          INC   HL   
          LD   (FEEDER_CHIN),HL   
          OR   a   ; Check if zero, null-terminated script
          POP   HL   
          JR   z,End_feeding_chin   
          RET      
          ENDIF      
END_FEEDING_CHIN:      
             ; =======================END FEEDER
POLLSERIAL:      
nokey:
          IF   DEBUG = FALSE   
          call in0a_STAT1 ; The CALL here is because I had macro/conditional nesting issues
          AND   10000000b   
          JR    nz,have_serial
          JR   z,no_serial
have_serial:
	      call in0a_RDR1 ; The CALL here is because I had macro/conditional nesting issues
          jr have_input
no_serial:
          RST08H_05_GETKEY_retD_Cflag
          JR    nc,nokey
          cp 2
          jr z,notreturn
          ld a,13
          jr have_input
notreturn: and a ; detect 0
          jr z,notspace
          ld a,20h
notspace: cp 157 ;"CODE-"P-BREAK" on the Brother keyboard
          jr z,notbreak
          ld a,3 ;CTRL-C for BASIC.
notbreak:
have_input:
          CP   27   
          JP   z,apl_code_normal_start   
          ELSE  ; For running in emulation:
          NOP      ; SERIAL INPUT into A..
          NOP      ; 
          ENDIF      
          RET      
             ; The dual serial poll is not in use at the moment.
pollserialboth:
pollserialboth0:
        call in0a_STAT0  ; The CALL here is because I had macro/conditional nesting issues
        and 10000000b
        jr  z, pollserialboth1
        call in0a_RDR0  ; The CALL here is because I had macro/conditional nesting issues
          CP   27   
          JP   z,apl_code_normal_start   
        ret	
pollserialboth1:
        call in0a_STAT1  ; The CALL here is because I had macro/conditional nesting issues
        and 10000000b
        jr  z, pollserialboth0
        call in0a_RDR1  ; The CALL here is because I had macro/conditional nesting issues
          CP   27   
          JP   z,apl_code_normal_start   
        ret	
             ;.if TRUE = FALSE
chin_timeout:  ; THIS variant uses a timeout and returns a character when the timeout expires
pollserialbotht:
        push de
        ld d,255
        ld e,d
pollserialbotht0:
             ; do timeout
        dec e
        jr nz,pollnocarryt
pollcarryt: 
        dec d
        jr nz,pollnocarryt
    ;  Uncomment the character you would return.
;        ld a,"."  ;Use this to define a "timeout" response.
;        ld a,255  ;Use this to define a "timeout" response.
        ld a,0  ;Use this to define a "timeout" response.
        pop de
        ret  
pollnocarryt:
        in0a    STAT0
        and 10000000b
        jr  z, pollserialbotht1
        in0a     RDR0
        pop de
        ret	
pollserialbotht1:
        in0a    STAT1
        and 10000000b
        jr  z, pollserialbotht0
        in0a     RDR1
        pop de
        ret	
             ;.endif
             ;.if TRUE = FALSE
check_serial0in:
        in0a    STAT0
        and 10000000b
        ret
check_serial1in:
        in0a    STAT0
        and 10000000b
        ret

check_serialeither:
        in0a    STAT0
        and 10000000b
        jr  z, chkserialeither1
        ret	
chkserialeither1:
        in0a    STAT1
        and 10000000b
        ret 
             ;.endif
TEST_Z80_IN:      ;testing I/O without HD64180 extended instructions
          in0a    STAT1 ;use the 64180 instr. to check
          AND   10000000b   
          LD   a,0   ; A is used for the high 8 bits of I/O address on HD64180 for this opcode.
          IN   a,(RDR1)   
          CP   "q"   
          RET   z   
          CALL   MONOUT   
          JP   Test_Z80_In   
TEST_Z80_OUT:      ;testing I/O without HD64180 extended instructions
          CALL   chin   
          CP   "q"   
          RET   z   
          LD   b,0   ; This is more tedious than the IN instruction b/c it needs BC.
          LD   c,TDR1   
          OUT   (C),a   
          JP   Test_Z80_In   
TEST_CHKIO_SURROGATE_ECHO:      ;This is failing on its own.
          CALL   chkio_surrogate   
          JR   nz,havecharsurrogate   
             ; Got zero flag from my surrogate, what about?
          LD   b,a   
          LD   a,"Z"   
          CALL   MONOUT   
          LD   a,b   
HAVECHARSURROGATE:      
          CALL   puthexbyte   
          JP   Test_CHKIO_SURROGATE_echo   
TEST_CHKIO_ECHO:      
;          CALL   CHKIO   ; Chkio should act similarly to my surrogate.  Return z if nothing.
          JR   nz,havecharchkio   
             ; Got zero flag, what about?
          LD   b,a   
          LD   a,"Z"   
          CALL   MONOUT   
          LD   a,b   
HAVECHARCHKIO:      
          CALL   puthexbyte   
          JP   Test_CHKIO_echo   


	 .MACRO DWA   ; %%1 is WHERE
	DB	((%%1 /256) | 128)
	DB	(%%1 & 0FFH)
	 .ENDM

; this is from TINYBASIC
CRLF:	LD	A,CR		; *** CRLF ***
    call MONOUT
	CP	CR		; WAS IT CR?
	RET	NZ		; NO, FINISHED
	LD	A,LF		; YES, WE SEND LF TOO
    CALL MONOUT
	LD	A,CR		; GET CR BACK IN A
	RET
;
; this is from TINYBASIC
CHKIO:
    ret;
;    call chkio_surrogate ;jc adding
;	RET	Z		; NOT READY, RETURN "Z"
;	AND	7FH		; MASK BIT 7 OFF
;	CP	0FH		; IS IT CONTROL-O?
;	JP	NZ,CI1		; NO, MORE CHECKING
;	LD	A,(OCSW)	; CONTROL-O FLIPS OCSW
;	CPL			; ON TO OFF, OFF TO ON
;	LD	(OCSW),A
;	JP	CHKIO		; GET ANOTHER INPUT
;CI1:	CP	3H		; IS IT CONTROL-C?
;	RET	NZ		; NO, RETURN "NZ"
;	JP	RSTART		; YES, RESTART TBI
;



.align 0x100

; JC INSERTING MONITOR

; JC INSERTING MONITOR
.align 0x100
; from Cpuville: http://cpuville.com/Code/Z80.html 
;RAM monitor for a system with serial interface and IDE disk and memory expansion board.
;This program to be loaded by CP/M at 0100h, then it copies itself to memory at DC00h.
;Assumes serial port has been initialized by ROM monitor.
;NOT:Assumes the UART data port address is 02h and control/status address is 03h
;Assumes memory configuration is all-RAM
;JC HARTDHAT: The above line is from previous author and may represent a problem.
;The subroutines use these variables in RAM, same area as ROM monitor:
current_location:	equ	0xdb00		;word variable in RAM
line_count:		equ	0xdb02		;byte variable in RAM
byte_count:		equ	0xdb03		;byte variable in RAM
value_pointer:		equ	0xdb04		;word variable in RAM
current_value:		equ	0xdb06		;word variable in RAM
monbuffer:			equ	0xdb08		;buffer in RAM -- up to stack area
;Will use stack of calling program (CP/M) which is re-initialized at re-boot.
;
;
;
;Code to start program and move to higher memory
;JC says THIS BIT RELOCATES THE MONITOR.  I won't be relocating it.
;JC removing org.  It has to be after the previous org.
;			org	0100h
;
;			ld	hl,code_origin	;start of code to transfer
;			ld	bc,monitor_code_end-code_start+1	;length of code to transfer
;			ld	de,0DC00h	;target of transfer
;			ldir			;Z80 transfer instruction
;			jp	0DC00h
code_origin:					;address of first byte of code before transfer
;	
;JC removing org.  It has to be after the previous org.
;			org	0DC00h
code_start:		jp 	monitor_start			
;
;Puts a single char (byte value) on serial output
;Call with char to send in A register. Uses B register
;JC CHANGING.
;write_char:		ld	b,a			;store char
;write_char_loop:	in	a,(3)			;check if OK to send
;			and	001h			;check TxRDY bit
;			jp 	z,write_char_loop	;loop if not set
;			ld 	a,b			;get char back
;			out 	(2),a			;send to output
;			ret				;returns with char in a
;JC changing:
write_char:
    jp MONOUT

;
;Subroutine to write a zero-terminated string to serial output
;Pass address of string in HL register
;No error checking
; JC CHANGING!  
;write_string:
;           in 	a,(3)			;read status
;			and 	001h			;check TxRDY bit
;			jp 	z,write_string		;loop if not set
;			ld 	a,(hl)			;get char from string
;			and 	a			;check if 0
;			ret 	z			;yes, finished
;			out 	(2),a			;no, write char to output
;			inc 	hl			;next char in string
;			jp 	write_string		;start over

write_string:
			ld 	a,(hl)			;get char from string
			and 	a			;check if 0
			ret 	z			;yes, finished
			call MONOUT
			inc 	hl			;next char in string
			jp 	write_string		;start over

;
;Binary loader. Receive a binary file, place in memory.
;Address of load passed in HL, length of load (= file length) in BC
bload:      ;
; JC CHANGING FOR THIS HARDWARE
;            in 	a,(3)			;get status
;			and 	002h			;check RxRDY bit
;			jp 	z,bload			;not ready, loop
;			in	a,(2)
            call chin
			ld	(hl),a
			inc	hl
			dec	bc			;byte counter
			ld	a,b			;need to test BC this way because
			or	c			;dec rp instruction does not change flags
			jp	nz,bload
			ret
;
;Binary dump to port. Send a stream of binary data from memory to serial output
;Address of dump passed in HL, length of dump in BC
bdump:		;
; JC CHANGING FOR THIS HARDWARE
;        	in 	a,(3)			;get status
;			and 	001h			;check TxRDY bit
;			jp 	z,bdump			;not ready, loop
			ld	a,(hl)
;			out	(2),a
            call MONOUT
			inc	hl
			dec	bc
			ld	a,b			;need to test this way because
			or	c			;dec rp instruction does not change flags
			jp	nz,bdump
			ret
;
;Subroutine to get a string from serial input, place in buffer.
;Buffer address passed in HL reg.
;Uses A,BC,DE,HL registers (including calls to other subroutines).
;Line entry ends by hitting return key. Return char not included in string (replaced by zero).
;Backspace editing OK. No error checking.
;
get_line:		ld	c,000h			;line position
			ld	a,h			;put original buffer address in de
			ld	d,a			;after this don't need to preserve hl
			ld	a,l			;subroutines called don't use de
			ld	e,a
get_line_next_char:
;JC changing this code for serial in.
;            in 	a,(3)			;get status
;			and 	002h			;check RxRDY bit
;			jp 	z,get_line_next_char	;not ready, loop
;			in 	a,(2)			;get char
            call chin
			cp	00dh			;check if return
			ret	z			;yes, normal exit
			cp	07fh			;check if backspace (VT102 keys)
			jp	z,get_line_backspace	;yes, jump to backspace routine
			cp	008h			;check if backspace (ANSI keys)
			jp	z,get_line_backspace	;yes, jump to backspace
			call	write_char		;put char on screen
			ld	(de),a			;store char in buffer
			inc	de			;point to next space in buffer
			inc	c			;inc counter
			ld	a,000h
			ld	(de),a			;leaves a zero-terminated string in buffer
			jp	get_line_next_char
get_line_backspace:	ld	a,c			;check current position in line
			cp	000h			;at beginning of line?
			jp	z,get_line_next_char	;yes, ignore backspace, get next char
			dec	de			;no, erase char from buffer
			dec	c			;back up one
			ld	a,000h			;put a zero in buffer where the last char was
			ld	(de),a
			ld	hl,erase_char_string	;ANSI sequence to delete one char from line
			call	write_string		;transmits sequence to backspace and erase char
			jp	get_line_next_char
;
;Creates a two-char hex string from the byte value passed in register A
;Location to place string passed in HL
;String is zero-terminated, stored in 3 locations starting at HL
;Also uses registers b,d, and e
byte_to_hex_string:	ld	b,a			;store original byte
			srl	a			;shift right 4 times, putting
			srl	a			;high nybble in low-nybble spot
			srl	a			;and zeros in high-nybble spot
			srl	a
			ld	d,000h			;prepare for 16-bit addition
			ld	e,a			;de contains offset
			push	hl			;temporarily store string target address
			ld	hl,hex_char_table	;use char table to get high-nybble character
			add	hl,de			;add offset to start of table
			ld	a,(hl)			;get char
			pop	hl			;get string target address
			ld	(hl),a			;store first char of string
			inc	hl			;point to next string target address
			ld	a,b			;get original byte back from reg b
			and	00fh			;mask off high-nybble
			ld	e,a			;d still has 000h, now de has offset
			push	hl			;temp store string target address
			ld	hl,hex_char_table	;start of table
			add	hl,de			;add offset
			ld	a,(hl)			;get char
			pop	hl			;get string target address
			ld	(hl),a			;store second char of string
			inc	hl			;point to third location
			ld	a,000h			;zero to terminate string
			ld	(hl),a			;store the zero
			ret				;done
;
;Converts a single ASCII hex char to a nybble value
;Pass char in reg A. Letter numerals must be upper case. ; JC changing this..
;Return nybble value in low-order reg A with zeros in high-order nybble if no error.
;Return 0ffh in reg A if error (char not a valid hex numeral).
;Also uses b, c, and hl registers.
; JC adjusted this to allow for lowercase.
hex_char_to_nybble:	ld	hl,hex_char_table2
			ld	b,21			;no. of valid characters in table - 1.
			ld	c,0Ah			;will be nybble value
hex_to_nybble_loop:	cp	(hl)			;character match here?
			jp	z,hex_to_nybble_ok	;match found, exit
			dec	b			;no match, check if at end of table
			jp	m,hex_to_nybble_err	;table limit exceded, exit with error
			inc	c			;still inside table, continue search
			inc	hl
			jp	hex_to_nybble_loop
hex_to_nybble_ok:
			ld	a,c			;put nybble value in a
          		AND   0Fh  			;fix for upper/lower
			ret
hex_to_nybble_err:	ld	a,0ffh			;error value
			ret
HEX_CHAR_TABLE2:   defb  "abcdef"   ; For conversion from lowercase & uppercase
HEX_CHAR_TABLE:   defb  "0123456789ABCDEF"   ;ASCII hex table, for conv. to hex
;
;Converts a hex character pair to a byte value
;Called with location of high-order char in HL
;If no error carry flag clear, returns with byte value in register A, and
;HL pointing to next mem location after char pair.
;If error (non-hex char) carry flag set, HL pointing to invalid char
hex_to_byte:
			ld	a,(hl)			;location of character pair
			push	hl			;store hl (hex_char_to_nybble uses it)
			call	hex_char_to_nybble
			pop	hl			;returns with nybble value in a reg, or 0ffh if error
			cp	0ffh			;non-hex character?
			jp	z,hex_to_byte_err	;yes, exit with error
			sla	a			;no, move low order nybble to high side
			sla	a
			sla	a
			sla	a
			ld	d,a			;store high-nybble
			inc	hl			;get next character of the pair
			ld	a,(hl)
			push	hl			;store hl
			call	hex_char_to_nybble
			pop	hl
			cp	0ffh			;non-hex character?
			jp	z,hex_to_byte_err	;yes, exit with error
			or	d			;no, combine with high-nybble
			inc	hl			;point to next memory location after char pair
			scf
			ccf				;no-error exit (carry = 0)
			ret
hex_to_byte_err:	scf				;error, carry flag set
			ret
;
;Subroutine to get a two-byte address from serial input.
;Returns with address value in HL
;Uses locations in RAM for buffer and variables
address_entry:		ld	hl,monbuffer		;location for entered string
			call	get_line		;returns with address string in buffer
			ld	hl,monbuffer		;location of stored address entry string
			call	hex_to_byte		;will get high-order byte first
			jp	c, address_entry_error	;if error, jump
			ld	(current_location+1),a	;store high-order byte, little-endian
			ld	hl,monbuffer+2		;point to low-order hex char pair
			call	hex_to_byte		;get low-order byte
			jp	c, address_entry_error	;jump if error
			ld	(current_location),a	;store low-order byte in lower memory
			ld	hl,(current_location)	;put memory address in hl
			ret
address_entry_error:	ld	hl,address_error_msg
			call	write_string
			jp	address_entry
;
;Subroutine to get a decimal string, return a word value
;Calls decimal_string_to_word subroutine
decimal_entry:		ld	hl,monbuffer
			call	get_line		;returns with DE pointing to terminating zero
			ld	hl,monbuffer
			call	decimal_string_to_word
			ret	nc			;no error, return with word in hl
			ld	hl,decimal_error_msg	;error, try again
			call	write_string
			jp	decimal_entry
;
;Subroutine to convert a decimal string to a word value
;Call with address of string in HL, pointer to end of string in DE
;Carry flag set if error (non-decimal char)
;Carry flag clear, word value in HL if no error.
decimal_string_to_word:	ld	b,d
			ld	c,e			;use BC as string pointer
			ld	(current_location),hl	;store addr. of start of buffer in RAM word variable
			ld	hl,000h			;starting value zero
			ld	(current_value),hl
			ld	hl,decimal_place_value	;pointer to values
			ld	(value_pointer),hl
decimal_next_char:	dec	bc			;next char in string (moving right to left)
			ld	hl,(current_location)	;check if at end of decimal string
			scf				;get ready to subtract de from buffer addr.
			ccf				;set carry to zero (clear)
			sbc	hl,bc			;keep going if bc > or = hl (buffer address)
			jp	c,decimal_continue	;borrow means bc > hl
			jp	z,decimal_continue	;z means bc = hl
			ld	hl,(current_value)	;return if de < buffer address (no borrow)
			scf				;get value back from RAM variable
			ccf
			ret				;return with carry clear, value in hl
decimal_continue:	ld	a,(bc)			;next char in string (right to left)
			sub	030h			;ASCII value of zero char
			jp	m,decimal_error		;error if char value less than 030h
			cp	00ah			;error if byte value > or = 10 decimal
			jp	p,decimal_error		;a reg now has value of decimal numeral
			ld	hl,(value_pointer)	;get value to add an put in de
			ld	e,(hl)			;little-endian (low byte in low memory)
			inc	hl
			ld	d,(hl)
			inc	hl			;hl now points to next value
			ld	(value_pointer),hl
			ld	hl,(current_value)	;get back current value
decimal_add:		dec	a			;add loop to increase total value
			jp	m,decimal_add_done	;end of multiplication
			add	hl,de
			jp	decimal_add
decimal_add_done:	ld	(current_value),hl
			jp	decimal_next_char
decimal_error:		scf
			ret
			jp	decimal_add
decimal_place_value:	defw	1,10,100,1000,10000
;
;Memory dump
;Displays a 256-byte block of memory in 16-byte rows.
;Called with address of start of block in HL
memory_dump:;
    		ld	(current_location),hl	;store address of block to be displayed
			ld	a,000h
			ld	(byte_count),a		;initialize byte count
			ld	(line_count),a		;initialize line count
			jp	dump_new_line
dump_next_byte:		ld	hl,(current_location)	;get byte address from storage,
			ld	a,(hl)			;get byte to be converted to string
			inc	hl			;increment address and
			ld	(current_location),hl	;store back
			ld	hl,monbuffer		;location to store string
			call	byte_to_hex_string	;convert
			ld	hl,monbuffer		;display string
			call	write_string
			ld	a,(byte_count)		;next byte
			inc	a
			jp	z,dump_done		;stop when 256 bytes displayed
			ld	(byte_count),a		;not finished yet, store
			ld	a,(line_count)		;end of line (16 characters)?
			cp	00fh			;yes, start new line
			jp	z,dump_new_line
			inc	a			;no, increment line count
			ld	(line_count),a
			ld	a,020h			;print space
			call	write_char
			jp	dump_next_byte		;continue
dump_new_line:		ld	a,000h			;reset line count to zero
			ld	(line_count),a			
			call	write_newline
			ld	hl,(current_location)	;location of start of line
			ld	a,h			;high byte of address
			ld	hl,monbuffer
			call	byte_to_hex_string	;convert
			ld	hl,monbuffer
			call	write_string		;write high byte
			ld	hl,(current_location)
			ld	a,l			;low byte of address
			ld	hl,monbuffer
			call	byte_to_hex_string	;convert
			ld	hl,monbuffer
			call	write_string		;write low byte
			ld	a,020h			;space
			call	write_char
			jp	dump_next_byte		;now write 16 bytes
dump_done:		ld	a,000h
			ld	hl,monbuffer
			ld	(hl),a			;clear buffer of last string
			call	write_newline
			ret
;
;Memory load
;Loads RAM memory with bytes entered as hex characters
;Called with address to start loading in HL
;Displays entered data in 16-byte rows.
memory_load:;
    		ld	(current_location),hl
			ld	hl,data_entry_msg
			call	write_string
			jp	load_new_line
load_next_char:		call	get_char
			cp	00dh			;return?
			jp	z,load_done		;yes, quit
			ld	(monbuffer),a
			call	get_char
			cp	00dh			;return?
			jp	z,load_done		;yes, quit
			ld	(monbuffer+1),a
			ld	hl,monbuffer
			call	hex_to_byte
			jp	c,load_data_entry_error	;non-hex character
			ld	hl,(current_location)	;get byte address from storage,
			ld	(hl),a			;store byte
			inc	hl			;increment address and
			ld	(current_location),hl	;store back
			ld	a,(monbuffer)
			call	write_char
			ld	a,(monbuffer+1)
			call	write_char
			ld	a,(line_count)		;end of line (16 characters)?
			cp	00fh			;yes, start new line
			jp	z,load_new_line
			inc	a			;no, increment line count
			ld	(line_count),a
			ld	a,020h			;print space
			call	write_char
			jp	load_next_char		;continue
load_new_line:		ld	a,000h			;reset line count to zero
			ld	(line_count),a
			call	write_newline
			jp	load_next_char		;continue
load_data_entry_error:	call	write_newline
			ld	hl,data_error_msg
			call	write_string
			ret
load_done:		call	write_newline
			ret
;
;Get one ASCII character from the serial port.
;Returns with char in A reg. No error checking.
;get_char:		in 	a,(3)			;get status
;			and 	002h			;check RxRDY bit
;			jp 	z,get_char		;not ready, loop
;			in 	a,(2)			;get char
;			ret

;JC CHANGING GET_CHAR:
get_char:
    jp chin;

;
;Subroutine to start a new line
write_newline:
            ld	a,00dh			;ASCII carriage return character
			call	write_char
			ld	a,00ah			;new line (line feed) character
			call	write_char
			ret
;
;Subroutine to read one disk sector (256 bytes)
;Address to place data passed in HL
;LBA bits 0 to 7 passed in C, bits 8 to 15 passed in B
;LBA bits 16 to 23 passed in E
disk_read:;
            ret ;JC nullifying
    

rd_status_loop_1:	in	a,(0fh)		;check status
			and	80h		;check BSY bit
			jp	nz,rd_status_loop_1	;loop until not busy
rd_status_loop_2:	in	a,(0fh)		;check	status
			and	40h		;check DRDY bit
			jp	z,rd_status_loop_2	;loop until ready
			ld	a,01h		;number of sectors = 1
			out	(0ah),a		;sector count register
			ld	a,c
			out	(0bh),a		;lba bits 0 - 7
			ld	a,b
			out	(0ch),a		;lba bits 8 - 15
			ld	a,e
			out	(0dh),a		;lba bits 16 - 23
			ld	a,11100000b	;LBA mode, select drive 0
			out	(0eh),a		;drive/head register
			ld	a,20h		;Read sector command
			out	(0fh),a
rd_wait_for_DRQ_set:	in	a,(0fh)		;read status
			and	08h		;DRQ bit
			jp	z,rd_wait_for_DRQ_set	;loop until bit set
rd_wait_for_BSY_clear:	in	a,(0fh)
			and	80h
			jp	nz,rd_wait_for_BSY_clear
			in	a,(0fh)		;clear INTRQ
read_loop:		in	a,(08h)		;get data
			ld	(hl),a
			inc	hl
			in	a,(0fh)		;check status
			and	08h		;DRQ bit
			jp	nz,read_loop	;loop until cleared
			ret
;
;Subroutine to write one disk sector (256 bytes)
;Address of data to write to disk passed in HL
;LBA bits 0 to 7 passed in C, bits 8 to 15 passed in B
;LBA bits 16 to 23 passed in E
disk_write:;
            ret ;JC nullifying
    

wr_status_loop_1:	in	a,(0fh)		;check status
			and	80h		;check BSY bit
			jp	nz,wr_status_loop_1	;loop until not busy
wr_status_loop_2:	in	a,(0fh)		;check	status
			and	40h		;check DRDY bit
			jp	z,wr_status_loop_2	;loop until ready
			ld	a,01h		;number of sectors = 1
			out	(0ah),a		;sector count register
			ld	a,c
			out	(0bh),a		;lba bits 0 - 7
			ld	a,b
			out	(0ch),a		;lba bits 8 - 15
			ld	a,e
			out	(0dh),a		;lba bits 16 - 23
			ld	a,11100000b	;LBA mode, select drive 0
			out	(0eh),a		;drive/head register
			ld	a,30h		;Write sector command
			out	(0fh),a
wr_wait_for_DRQ_set:	in	a,(0fh)		;read status
			and	08h		;DRQ bit
			jp	z,wr_wait_for_DRQ_set	;loop until bit set			
write_loop:		ld	a,(hl)
			out	(08h),a		;write data
			inc	hl
			in	a,(0fh)		;read status
			and	08h		;check DRQ bit
			jp	nz,write_loop	;write until bit cleared
wr_wait_for_BSY_clear:	in	a,(0fh)
			and	80h
			jp	nz,wr_wait_for_BSY_clear
			in	a,(0fh)		;clear INTRQ
			ret
;
;Strings used in subroutines
length_entry_string:	db	"Enter length of file to load (decimal): ",0
dump_entry_string:	db	"Enter no. of bytes to dump (decimal): ",0
LBA_entry_string:	db	"Enter LBA (decimal, 0 to 65535): ",0
erase_char_string:	db	008h,01bh,"[K",000h	;ANSI sequence for backspace, erase to end of line.
address_entry_msg:	db	"Enter 4-digit hex address (use upper-case A through F): ",0
address_error_msg:	db	"\r\nError: invalid hex character, try again: ",0
data_entry_msg:		db	"Enter hex bytes, hit return when finished.\r\n",0
data_error_msg:		db	"Error: invalid hex byte.\r\n",0
decimal_error_msg:	db	"\r\nError: invalid decimal number, try again: ",0
;
;Simple monitor program for CPUville Z80 computer with serial interface.
; JC CODE GOT REFORMATTED WHEN LOST/RECOVERED:
             ; JC using this monitor in RAM, so these storage variables will be in RAM.
STORE_AF:   defs  2   
STORE_BC:   defs  2   
STORE_DE:   defs  2   
STORE_HL:   defs  2   
STORE_SP:   defs  2   
STORE_PC:   defs  2   
             ;JC HARDHAT AREA RETURN HERE:
EMPTY_SPACE:   defs  24   ; Prevent a crash if overrun during user entry.
             ; Alternately, the above entry ca be put somewhere else.
             ;JC HARDHAT AREA RETURN HERE^^
CPU_8080_FLAGS:   EQU   0b00000001   ; First in the series?
CPU_8085_FLAGS:   EQU   0b00000011   ; Not sure what is different about 8085, RETURN HERE
CPU_Z80_FLAGS:   EQU   0b00000101   
CPU_HD64180_FLAGS:   EQU   0b00001101   ; Enable MMU support.
CPU_Z180_FLAGS:   EQU   0b00011101   ; Z180 has different serial port options at least.
CPU_MMUFLAG:   EQU   0b00001000   
CPU_16IOFLAG:   EQU   0b00001000   ; also represents 16-bit I/O opcodes and capability
CPU_ID_MESSAGE:   defb  "CPU type is ",0   
CPU_8080_NAME:   defb  "8080",0   
CPU_8085_NAME:   defb  "8085",0   
CPU_Z80_NAME:   defb  "Z80",0   
CPU_HD64180_NAME:   defb  "HD64180",0   
CPU_Z180_NAME:   defb  "Z80180",0   
CPU_ID_FLAGS:   defb  1   
CPU_IDSTRING_PTR:   defb  2   
RST_CALL:   RST   0   ;Self-modifying code here, modifies this byte and calls it.
          RET      
RST_LIST:      
          RST   0   ; I don't plan to use RST 0 but providing it anyway.
          RST   8   ; aka RST 1
          RST   10h   ; aka RST 2
          RST   18h   
          RST   20h   ; aka RST 2
          RST   28h   
          RST   30h   ; aka RST 2
          RST   38h   
ID_CPU:      
             ; call id_cpu  JC NOT DOING THIS YET.  RETURN HERE
             ; ASSUMING HD64180 for our purposes right now september 2019
             ; NEED TO FIND CODE THAT IDENTIFIES THE CPU CLASS.
          IF   DEBUG   
          LD   a,CPU_Z80_flags   
          LD   (CPU_ID_FLAGS),a   
          LD   hl,CPU_Z80_name   
          LD   (CPU_IDSTRING_PTR),hl   
          ELSE      
          LD   a,CPU_HD64180_flags   
          LD   (CPU_ID_FLAGS),a   
          LD   hl,CPU_HD64180_name   
          LD   (CPU_IDSTRING_PTR),hl   
          ENDIF      
          RET      
             ; JC FOUND THIS CODE by theevilmuffinofdoom, it is a step in the right direction:
             ;---------------------------
             ;https://www.reddit.com/r/osdev/comments/5lhvqq/how_do_you_differentiate_between_an_8080_and_z80/
             ;---------------------------
             ; Stack pointer should be set up before this!
             ; set the zero flag but not sign flag, and clear the subtraction flag
          LD   A,255   
          INC   A   
          PUSH   AF   
          LD   HL,0   
          ADD   HL,SP   ; can't load sp directly into hl for some reason
             ; (HL) should now be flags register
          LD   A,$82   ; mask off everything but bits 7 and 1
          AND   (HL)   
          CP   $80   
          JP   Z,is_LR35902   ; zero flag was set and bit 1 was clear
          CP   $0   
          JP   Z,is_Z80   ; sign flag was not set and subtract bit was clear
             ; else it must be 8080
IS_8080:      
             ; set some byte somewhere to indicate it is 8080
          JP   end   
IS_LR35902:      ; JC: DMG or Gameboy?
             ; set some byte somewhere to indicate it is LR35902
          JP   end   
IS_Z80:      
             ; set some byte somewhere to indicate it is Z80
END:         
          POP   AF   
             ;---------------------------
REPORT_CPU:      
          LD   hl,CPU_ID_MESSAGE   
          CALL   write_string   
          LD   hl,(CPU_IDSTRING_PTR)   
          CALL   write_string   
          RET      
             ;TEST CALLABLE FUNCTION
         .align   256   
TESTROUTINE:      
          CALL   puthexbyte   
          CALL   puthexword   
          LD   a,12h   
          LD   bc,3456h   
          CP   14h   
          RET      
monitor_pre_start:
             ; Store register state
.if   1   
          PUSH   AF   
          LD   (STORE_BC),BC   
          LD   (STORE_DE),DE   
          LD   (STORE_HL),HL   
          POP   BC   
          LD   (STORE_AF),BC   
          LD   BC,0   
          LD   H,B   
          LD   L,B   ; HL=0 NOW
          ADD   HL,SP   ; HERE IS THE STACK ;this method is from TINY BASIC
          LD   (STORE_SP),HL   
             ;LD bc,(hl) ;This is the return PC, for what it's worth.
          LD   c,(hl)   
          INC   hl   
          LD   b,(hl)   
          LD   (STORE_PC),bc   
.endif
; END, JC CODE GOT REFORMATTED WHEN LOST/RECOVERED.

          CALL   ConfigureSerial   ;Maybe this should be done locally for a sturdier monitor.
            ld	hl,monitor_message
			call	write_string
          call   id_cpu   ; ASSUMES HD64180 for our purposes right now september 2019
          call   REPORT_CPU   
          call   write_newline   
monitor_start:
          CALL   report_regs   ; JC adding this stuff to report current running state
            ld	hl,monitor_prompt
			call	write_string
			
             ;routine program return here to avoid re-initialization of port
		;	ld	a,03eh			;cursor symbol
		;	call	write_char
			ld	hl,monbuffer
			call	get_line		;get monitor input string (command)
			call	write_newline
			call	parse			;interprets command, returns with address to jump to in HL
			jp	(hl)
;
;Parses an input line stored in buffer for available commands as described in parse table.
;Returns with address of jump to action for the command in HL
parse:			ld	bc,parse_table		;bc is pointer to parse_table
parse_start:		ld	a,(bc)			;get pointer to match string from parse table
			ld	e,a
			inc	bc
			ld	a,(bc)			
			ld	d,a			;de will is pointer to strings for matching
			ld	a,(de)			;get first char from match string
			or	000h			;zero?
			jp	z,parser_exit		;yes, exit no_match
			ld	hl,monbuffer		;no, parse input string 
match_loop:		cp	(hl)			;compare buffer char with match string char
			jp	nz,no_match		;no match, go to next match string
			or	000h			;end of strings (zero)?
			jp	z,parser_exit		;yes, matching string found
			inc	de			;match so far, point to next char in match string
			ld	a,(de)			;get next character from match string
			inc	hl			;and point to next char in input string
			jp	match_loop		;check for match
no_match:		inc	bc			;skip over jump target to
			inc	bc
			inc	bc			;get address of next matching string
			jp	parse_start
parser_exit:		inc	bc			;skip to address of jump for match
			ld	a,(bc)
			ld	l,a
			inc	bc
			ld	a,(bc)
			ld	h,a			;returns with jump address in hl
			ret
;
;Actions to be taken on match
;
;Memory dump program
;Input 4-digit hexadecimal address
;Calls memory_dump subroutine
dump_jump:		ld	hl,dump_message		;Display greeting
			call	write_string
			ld	hl,address_entry_msg	;get ready to get address
			call	write_string
			call	address_entry		;returns with address in HL
                        ; call	write_newline   ;Is write_newline trashing the address entry?
			call	memory_dump
			jp	monitor_start
;
;Hex loader, displays formatted input
load_jump:		ld	hl,load_message		;Display greeting
			call	write_string		;get address to load
			ld	hl,address_entry_msg	;get ready to get address
			call	write_string
			call	address_entry
			call	write_newline
			call	memory_load
			jp	monitor_start
;
;Jump and run do the same thing: get an address and jump to it.
run_jump:		ld	hl,run_message		;Display greeting
			call	write_string
			ld	hl,address_entry_msg	;get ready to get address
			call	write_string
			call	address_entry
			jp	(hl)
; JC CODE GOT REFORMATTED WHEN LOST/RECOVERED.
A_TEXT:   defb  "REGS A:",0   
F_TEXT:   defb  " FLAGS:",0   
BC_TEXT:   defb  "BC:",0   
DE_TEXT:   defb  " DE:",0   
HL_TEXT:   defb  " HL:",0   
SP_TEXT:   defb  " SP:",0   
PC_TEXT:   defb  " PC:",0   ; PC has no meaning if we aren't an interactive debugger.
SETREGS_ENTRY_MSG:   defb  "Enter registers as hex in form AAFFBBCCDDEEHHLLSSPP.\r\n"   
	defb  "Use 00(?) for F if not reqd. \r\nDon't need SP and don't overrrun!\r\n",0   
             ;SET ALL REGISTERS
SETREGS_JUMP:      
          CALL   report_regs   
          LD   hl,setregs_entry_msg   
          CALL   write_string   
          LD   hl,STORE_AF   
          LD   (current_location),hl   
          CALL   memory_load   
          CALL   regs_jump   
             ; flow into regs report
             ;REPORT the stored registers
REGS_JUMP:      
          CALL   report_regs   
          JP   monitor_start   
PUT1:        
          LD   a,"1"   
          CALL   MONOUT   
          RET      
PUT0:        
          LD   a,"0"   
          CALL   MONOUT   
          RET      
REPORT_REGS:      ; JC adding this.
             ;1st line A, Flags as hex, and Flags as bits
             ; Show A
          CALL   CRLF   
          LD   hl,A_text   
          CALL   write_string   
          LD   a,(STORE_AF)   
          CALL   puthexbyte   
             ; Show Flags byte as hex
          LD   hl,F_text   
          CALL   write_string   
          LD   a,(STORE_AF+1)   
          CALL   puthexbyte   
          LD   a," "   ; Gonna print out the individual flags
             ; WANT TO CHANGE THIS FOR INDIVIDUAL FLAG SYMBOLS AS APPROPRIATE
          CALL   MONOUT   
          LD   a,(STORE_AF+1)   
          LD   b,a   
          AND   0b10000000   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b01000000   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00100000   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00010000   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00001000   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00000100   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00000010   
          CALL   nz,put1   
          CALL   z,put0   
          LD   a,b   
          AND   0b00000001   
          CALL   nz,put1   
          CALL   z,put0   
          CALL   CRLF   
             ;2nd line BC, DE, HL, SP, PC
          LD   hl,BC_text   
          CALL   write_string   
          LD   bc,(STORE_BC)   
          CALL   puthexword   
          LD   hl,DE_text   
          CALL   write_string   
          LD   bc,(STORE_DE)   
          CALL   puthexword   
          LD   hl,HL_text   
          CALL   write_string   
          LD   bc,(STORE_HL)   
          CALL   puthexword   
          LD   hl,SP_text   
          CALL   write_string   
          LD   bc,(STORE_SP)   
          CALL   puthexword   
          LD   hl,PC_text   ;This may be wrong!  Looking for the return PC at best.
          CALL   write_string   
          LD   bc,(STORE_PC)   
          CALL   puthexword   
          CALL   CRLF   
          RET      
             ;Call would take stored parameters for all registers and calls the function.
             ; NOT implemented JC return here...
CALL_JUMP:      
          LD   hl,call_message   ;Display greeting
          CALL   write_string   
          LD   hl,address_entry_msg   ;get ready to get address
          CALL   write_string   
          CALL   address_entry   ; Get the target address from user
          LD   (call_opcode+1),hl   ; Self-modifying code.
          LD   bc,STORE_AF   
          PUSH   bc   ; AF needed right before the call
          LD   bc,STORE_BC   
          LD   de,STORE_DE   
          LD   hl,STORE_HL   ; get our return address
          POP   af   ; AF was pushed above, need to do it last,
             ; I think otherwise the flags may get clobbered
CALL_OPCODE:      ; Need this address for self-modifying code.
          CALL   00ffh   ; Self-modifying code; HL is put here to supply diff. HL
          IF   1   
          PUSH   AF   
          LD   (STORE_BC),BC   
          LD   (STORE_DE),DE   
          LD   (STORE_HL),HL   
          POP   BC   
          LD   (STORE_AF),BC   
          LD   BC,0   
          LD   H,B   
          LD   L,B   ; HL=0 NOW
          ADD   HL,SP   ; HERE IS THE STACK ;this method is from TINY BASIC
          LD   (STORE_SP),HL   
             ;LD bc,(hl) ;This is the return PC, for what it's worth.
          LD   c,(hl)   
          INC   hl   
          LD   b,(hl)   
          LD   (STORE_PC),bc   
          ENDIF      
          CALL   report_regs   
          JP   monitor_start   
             ;rst calls RST of the kind requested, and with stored registers.
             ; NOT implemented JC return here...
RST_JUMP:   LD   hl,rst_message   ;Display greeting
          CALL   write_string   
          LD   hl,address_entry_msg   ;get ready to get address
          CALL   write_string   
          CALL   address_entry   
RSTINS:   NOP      ; NOT DONE YET
          JP   monitor_start   
SHOWIO:      ; BC contains the address
          PUSH   af   
          LD   a,b   
          OR   a   
          JP   z,pagezeroonly   
          LD   a,b   
          CALL   puthexbyte   
PAGEZEROONLY:      
          LD   a,c   
          CALL   puthexbyte   
          LD   a,":"   
          CALL   MONOUT   
          IN   a,(C)   
          CALL   puthexbyte   
          LD   a," "   
          CALL   MONOUT   
          POP   af   
          RET      
INCMD_JUMP:   LD   hl,incmd_message   
          CALL   write_string   
          LD   bc,(STORE_BC)   
          CALL   showio   
          CALL   CRLF   
          JP   monitor_start   
RIGHTARROW:   defb  " -> ",0   
OUTCMD_JUMP:   LD   hl,outcmd_message   
          CALL   write_string   
             ;            call puthexword
             ;            ld a,":"
             ;            call puthexbyte
          LD   bc,(STORE_BC)   
          CALL   showio   
          LD   a,(STORE_AF)   
          OUT   (C),a   
          LD   hl,rightarrow   
          CALL   write_string   
          CALL   showio   
          CALL   CRLF   
          JP   monitor_start   
MMU_JUMP:      ;Report MMU status
             ;(38h) $60  CBR Common Base Register (external addr base of Common 1) ("high")
             ;(39h) $60  BBR Bank Base Register  (external addr base of Bank Area ("middle")
             ;(3Ah) $55 CBAR
          LD   hl,mmu_message   
          CALL   write_string   
          in0a 038h
          CALL   puthexbyte   
          in0a 039h
          CALL   puthexbyte   
          in0a 03Ah
          CALL   puthexbyte   
          CALL   crlf   
          JP   monitor_start   
; END, JC CODE GOT REFORMATTED WHEN LOST/RECOVERED.
             ; 
;Help and ? do the same thing, display the available commands
help_jump:		ld	hl,help_message
			call	write_string
			ld	bc,parse_table		;table with pointers to command strings
help_loop:		ld	a,(bc)			;displays the strings for matching commands,
			ld	l,a			;getting the string addresses from the
			inc	bc			;parse table
			ld	a,(bc)			;pass address of string to hl through a reg
			ld	h,a
			ld	a,(hl)			;hl now points to start of match string
			or	000h			;exit if no_match string
			jp	z,help_done
			push	bc			;write_char uses b register
			ld	a,020h			;space char
			call	write_char
			pop	bc
			call	write_string		;writes match string
			inc	bc			;pass over jump address in table
			inc	bc
			inc	bc
			jp	help_loop
help_done:		jp	monitor_start
;
;Binary file load. Need both address to load and length of file
bload_jump:		ld	hl,bload_message
			call	write_string
			ld	hl,address_entry_msg
			call	write_string
			call	address_entry
			call	write_newline
			push	hl
			ld	hl,length_entry_string
			call	write_string
			call	decimal_entry
			ld	b,h
			ld	c,l
			ld	hl,bload_ready_message
			call	write_string
			pop	hl
			call	bload
			jp	monitor_start
;
;Binary memory dump. Need address of start of dump and no. bytes
bdump_jump:		ld	hl,bdump_message
			call	write_string
			ld	hl,address_entry_msg
			call	write_string
			call	address_entry
			call	write_newline
			push	hl
			ld	hl,dump_entry_string
			call	write_string
			call	decimal_entry
			ld	b,h
			ld	c,l
			ld	hl,bdump_ready_message
			call	write_string
			call	get_char
			pop	hl
			call	bdump
			jp	monitor_start
;Disk read. Need memory address to place data, LBA of sector to read
diskrd_jump:		ld	hl,diskrd_message
			call	write_string
			ld	hl,address_entry_msg
			call	write_string
			call	address_entry
			call	write_newline
			push	hl
			ld	hl,LBA_entry_string
			call	write_string
			call	decimal_entry
			ld	b,h
			ld	c,l
			ld	e,00h
			pop	hl
			call	disk_read
			jp	monitor_start
diskwr_jump:		ld	hl,diskwr_message
			call	write_string
			ld	hl,address_entry_msg
			call	write_string
			call	address_entry
			call	write_newline
			push	hl
			ld	hl,LBA_entry_string
			call	write_string
			call	decimal_entry
			ld	b,h
			ld	c,l
			ld	e,00h
			pop	hl
			call	disk_write
			jp	monitor_start
cpm_jump:		jp	0000h			;reboot CP/M
QUIT_JUMP:   JP   apl_code_normal_start   ; Not sure which is better here, JP or RET.
          RET      ;                        ; Not sure which is better here, JP or RET.
             ; jp apl_code_normal_start is more likely to work,
             ; because the stack could be corrupted.
             ; However if the stack is corrupted, it may have extra items on it.
             ; "QUIT" is decidedly "return to the parent program."
             ; I think "EXIT" would be something to use if debugging, to resume a running program.
;Prints message for no match to entered command
no_match_jump:		ld	hl,no_match_message
			call	write_string
			ld	hl,monbuffer
			call	write_string
			jp	monitor_start
;
;Monitor data structures:
;
MONITOR_MESSAGE:   defb  "Donn Stewart CPUville Monitor w/JC Extensions\r\nType ? for command list.\r\n",0   
MONITOR_PROMPT:   defb  "\r\nMonitor ready > ",0   
NO_MATCH_MESSAGE:   defb  "? ",0   
HELP_MESSAGE:   defb  "Commands implemented:\r\n",0   
DUMP_MESSAGE:   defb  "Displays a 256-byte block of memory.\r\n",0   
LOAD_MESSAGE:   defb  "Enter hex bytes starting at memory location.\r\n",0   
run_message:		db	"Will jump to (execute) program at address entered.\r\n",0
REGS_MESSAGE:   defb  "Reports the values of registers on hold.\r\n",0   
CALL_MESSAGE:   defb  "Will call (execute) program at address entered,\r\n"   
 defb  "with the provided parameters, and return.\r\n",0   
RST_MESSAGE:   defb  "Will call the selected reset vector,\r\n"   
 defb  "with the provided parameters, and return.\r\n",0   
SETREGS_MESSAGE:   defb  "Enter hex for stored register values.\r\n",0   
INCMD_MESSAGE:   defb  "IN from I/O registers; BC is register address.\r\n",0   
OUTCMD_MESSAGE:   defb  "OUT to I/O registers; BC is register address.\r\n",0   
MMU_MESSAGE:   defb  "Report the MMU state CBR, BBR, and CBAR ($38, $39, $3A)\r\n",0   
bload_message:		db	"Loads a binary file into memory.\r\n",0
bload_ready_message:	db	"\r\nReady to receive, start transfer.",0
bdump_message:		db	"Dumps binary data from memory to serial port.\r\n",0
bdump_ready_message:	db	"\r\nReady to send, hit any key to start.",0
diskrd_message:		db	"Reads one sector from disk to memory.\r\n",0
diskwr_message:		db	"Writes one sector from memory to disk.\r\n",0
;Strings for matching:
dump_string:		db	"dump",0
load_string:		db	"load",0
jump_string:		db	"jump",0
run_string:		db	"run",0
REGS_STRING:   defb  "regs",0   
CALL_STRING:   defb  "call",0   
RST_STRING:   defb  "rst",0   
SETREGS_STRING:   defb  "setregs",0   
INCMD_STRING:   defb  "in",0   
OUTCMD_STRING:   defb  "out",0   
MMU_STRING:   defb  "mmu",0   
question_string:   defb  "?",0   
help_string:		db	"help",0
bload_string:		db	"bload",0
bdump_string:		db	"bdump",0
diskrd_string:		db	"diskrd",0
diskwr_string:		db	"diskwr",0
cpm_string:		db	"cpm",0
quit_string:   defb  "quit",0   
no_match_string:	db	0,0
;Table for matching strings to jumps
parse_table:
			defw	dump_string,dump_jump,load_string,load_jump
			defw	jump_string,run_jump,run_string,run_jump
          defw  regs_string,regs_jump   
          defw  call_string,call_jump   
          defw  rst_string,rst_jump   
          defw  setregs_string,setregs_jump   
          defw  incmd_string,incmd_jump   
          defw  outcmd_string,outcmd_jump   
          defw  mmu_string,mmu_jump   
			defw	question_string,help_jump,help_string,help_jump
			defw	bload_string,bload_jump,bdump_string,bdump_jump
			defw	diskrd_string,diskrd_jump,diskwr_string,diskwr_jump
			defw	cpm_string,cpm_jump
          defw  quit_string,quit_jump   
			defw	no_match_string,no_match_jump
monitor_code_end:
;			end

; END JC INSERTING MONITOR

; =======================================================================
; ORG    0399H           ; <<<< Modified to allow for Z180 Tx/Rx interrupt & HexLoadr
;==============================================================

;.align 256
tinybasic_start: 
nascombasic_start:
.if DEBUG = TRUE
     ORG    0399H           ; <<<< Modified to allow for Z180 Tx/Rx interrupt & HexLoadr
    
.endif
.ent $   ; ENTRY POINT FOR DEBUGGING. Debug entry.
;==============================================================
; JC WILL MAKE SMALL CHANGES TO CALL SERIAL FUNCTIONS.

COLD:   JP      STARTB          ; Jump in for cold start (0399H)
WARM:   JP      WARMST          ; Jump in for warm start (039CH)
STARTB: 
        ld      IX,0            ; Flag cold start
        JP      CSTART          ; Jump to initialise

        .WORD   DEINT           ; Get integer -32768 to 32767
        .WORD   ABPASS          ; Return integer in AB


CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
        ld      SP,HL           ; Set up a temporary stack
        JP      INITST          ; Go to initialise

INIT:   ld      DE,INITAB       ; Initialise workspace
        ld      B,INITBE-INITAB+3; Bytes to copy
        ld      HL,WRKSPC       ; Into workspace RAM
COPY:   ld      A,(DE)          ; Get source
        ld      (HL),A          ; To destination
        INC     HL              ; Next destination
        INC     DE              ; Next source
        DEC     B               ; Count bytes
        JP      NZ,COPY         ; More to move
        ld      SP,HL           ; Temporary stack
        CALL    CLREG           ; Clear registers and stack
        CALL    PRNTCRLF        ; Output CRLF
        ld      (BUFFER+72+1),A ; Mark end of buffer
        ld      (PROGST),A      ; Initialise program area
MSIZE:  ld      HL,MEMMSG       ; Point to message
        CALL    PRS             ; Output "Memory size"
        CALL    PROMPT          ; Get input with '?'
        CALL    GETCHR          ; Get next character
        OR      A               ; Set flags
        JP      NZ,TSTMEM       ; If number - Test if RAM there
        ld      HL,STLOOK       ; Point to start of RAM
MLOOP:  INC     HL              ; Next byte
        ld      A,H             ; Above address FFFF ?
        OR      L
        JP      Z,SETTOP        ; Yes - 64K RAM
        ld      A,(HL)          ; Get contents
        ld      B,A             ; Save it
        CPL                     ; Flip all bits
        ld      (HL),A          ; Put it back
        CP      (HL)            ; RAM there if same
        ld      (HL),B          ; Restore old contents
        JP      Z,MLOOP         ; If RAM - test next byte
        JP      SETTOP          ; Top of RAM found

TSTMEM: CALL    ATOH            ; Get high memory into DE
        OR      A               ; Set flags on last byte
        JP      NZ,SNERR        ; ?SN Error if bad character
        EX      DE,HL           ; Address into HL
        DEC     HL              ; Back one byte
        ld      A,11011001B     ; Test byte
        ld      B,(HL)          ; Get old contents
        ld      (HL),A          ; Load test byte
        CP      (HL)            ; RAM there if same
        ld      (HL),B          ; Restore old contents
        JP      NZ,MSIZE        ; Ask again if no RAM

SETTOP: DEC     HL              ; Back one byte
        ld      DE,STLOOK-1     ; See if enough RAM
        CALL    CPDEHL          ; Compare DE with HL
        JP      C,MSIZE         ; Ask again if not enough RAM
        ld      DE,0-50         ; 50 Bytes string space
        ld      (LSTRAM),HL     ; Save last available RAM
        ADD     HL,DE           ; Allocate string space
        ld      (STRSPC),HL     ; Save string space
        CALL    CLRPTR          ; Clear program area
        ld      HL,(STRSPC)     ; Get end of memory
        ld      DE,0-17         ; Offset for free bytes
        ADD     HL,DE           ; Adjust HL
        ld      DE,PROGST       ; Start of program text
        ld      A,L             ; Get LSB
        SUB     E               ; Adjust it
        ld      L,A             ; Re-save
        ld      A,H             ; Get MSB
        SBC     A,D             ; Adjust it
        ld      H,A             ; Re-save
        PUSH    HL              ; Save bytes free
        ld      HL,SIGNON       ; Sign-on message
        CALL    PRS             ; Output string
        POP     HL              ; Get bytes free back
        CALL    PRNTHL          ; Output amount of free memory
        ld      HL,BFREE        ; " Bytes free" message
        CALL    PRS             ; Output string

WARMST: ld      SP,STACK        ; Temporary stack
BRKRET: CALL    CLREG           ; Clear registers and stack
        JP      PRNTOK          ; Go to get command line

BFREE:  .BYTE   " Bytes free",CR,LF,0,0

SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
        .BYTE   "Copyright ",40,"C",41
        .BYTE   " 1978 by Microsoft",CR,LF,0,0

MEMMSG: .BYTE   "Memory top",0

; FUNCTION ADDRESS TABLE

FNCTAB: .WORD   SGN
        .WORD   INT
        .WORD   ABS
        .WORD   USR
        .WORD   FRE
        .WORD   INP
        .WORD   POS
        .WORD   SQR
        .WORD   RND
        .WORD   LOG
        .WORD   EXP
        .WORD   COS
        .WORD   SIN
        .WORD   TAN
        .WORD   ATN
        .WORD   PEEK
        .WORD   DEEK
        .WORD   POINT
        .WORD   LEN
        .WORD   STR
        .WORD   VAL
        .WORD   ASC
        .WORD   CHR
        .WORD   HEX
        .WORD   BIN
        .WORD   LEFT
        .WORD   RIGHT
        .WORD   MID

; RESERVED WORD LIST

WORDS:  .BYTE   'E'+80H,"ND"
        .BYTE   'F'+80H,"OR"
        .BYTE   'N'+80H,"EXT"
        .BYTE   'D'+80H,"ATA"
        .BYTE   'I'+80H,"NPUT"
        .BYTE   'D'+80H,"IM"
        .BYTE   'R'+80H,"EAD"
        .BYTE   'L'+80H,"ET"
        .BYTE   'G'+80H,"OTO"
        .BYTE   'R'+80H,"UN"
        .BYTE   'I'+80H,"F"
        .BYTE   'R'+80H,"ESTORE"
        .BYTE   'G'+80H,"OSUB"
        .BYTE   'R'+80H,"ETURN"
        .BYTE   'R'+80H,"EM"
        .BYTE   'S'+80H,"TOP"
        .BYTE   'O'+80H,"UT"
        .BYTE   'O'+80H,"N"
        .BYTE   'N'+80H,"ULL"
        .BYTE   'W'+80H,"AIT"
        .BYTE   'D'+80H,"EF"
        .BYTE   'P'+80H,"OKE"
        .BYTE   'D'+80H,"OKE"
        .BYTE   'S'+80H,"CREEN"
        .BYTE   'L'+80H,"INES"
        .BYTE   'C'+80H,"LS"
        .BYTE   'W'+80H,"IDTH"
        .BYTE   'M'+80H,"ONITOR"
        .BYTE   'S'+80H,"ET"
        .BYTE   'R'+80H,"ESET"
        .BYTE   'P'+80H,"RINT"
        .BYTE   'C'+80H,"ONT"
        .BYTE   'L'+80H,"IST"
        .BYTE   'C'+80H,"LEAR"
        .BYTE   'C'+80H,"LOAD"
        .BYTE   'C'+80H,"SAVE"
        .BYTE   'N'+80H,"EW"

        .BYTE   'T'+80H,"AB("
        .BYTE   'T'+80H,"O"
        .BYTE   'F'+80H,"N"
        .BYTE   'S'+80H,"PC("
        .BYTE   'T'+80H,"HEN"
        .BYTE   'N'+80H,"OT"
        .BYTE   'S'+80H,"TEP"

        .BYTE   '+'+80H
        .BYTE   '-'+80H
        .BYTE   '*'+80H
        .BYTE   '/'+80H
        .BYTE   '^'+80H
        .BYTE   'A'+80H,"ND"
        .BYTE   'O'+80H,"R"
        .BYTE   '>'+80H
        .BYTE   '='+80H
        .BYTE   '<'+80H

        .BYTE   'S'+80H,"GN"
        .BYTE   'I'+80H,"NT"
        .BYTE   'A'+80H,"BS"
        .BYTE   'U'+80H,"SR"
        .BYTE   'F'+80H,"RE"
        .BYTE   'I'+80H,"NP"
        .BYTE   'P'+80H,"OS"
        .BYTE   'S'+80H,"QR"
        .BYTE   'R'+80H,"ND"
        .BYTE   'L'+80H,"OG"
        .BYTE   'E'+80H,"XP"
        .BYTE   'C'+80H,"OS"
        .BYTE   'S'+80H,"IN"
        .BYTE   'T'+80H,"AN"
        .BYTE   'A'+80H,"TN"
        .BYTE   'P'+80H,"EEK"
        .BYTE   'D'+80H,"EEK"
        .BYTE   'P'+80H,"OINT"
        .BYTE   'L'+80H,"EN"
        .BYTE   'S'+80H,"TR$"
        .BYTE   'V'+80H,"AL"
        .BYTE   'A'+80H,"SC"
        .BYTE   'C'+80H,"HR$"
        .BYTE   'H'+80H,"EX$"
        .BYTE   'B'+80H,"IN$"
        .BYTE   'L'+80H,"EFT$"
        .BYTE   'R'+80H,"IGHT$"
        .BYTE   'M'+80H,"ID$"
        .BYTE   80H             ; End of list marker

; KEYWORD ADDRESS TABLE

WORDTB: .WORD   PEND
        .WORD   FOR
        .WORD   NEXT
        .WORD   DATA
        .WORD   INPUT
        .WORD   DIM
        .WORD   READ
        .WORD   LET
        .WORD   GOTO
        .WORD   RUN
        .WORD   IF
        .WORD   RESTOR
        .WORD   GOSUB
        .WORD   RETURN
        .WORD   REM
        .WORD   STOP
        .WORD   POUT
        .WORD   ON
        .WORD   NULL
        .WORD   WAIT
        .WORD   DEF
        .WORD   POKE
        .WORD   DOKE
        .WORD   REM
        .WORD   LINES
        .WORD   CLS
        .WORD   WIDTH
        .WORD   MONITR
        .WORD   PSET
        .WORD   RESET
        .WORD   PRINT
        .WORD   CONT
        .WORD   LIST
        .WORD   CLEAR
        .WORD   REM
        .WORD   REM
        .WORD   NEW

; RESERVED WORD TOKEN VALUES

ZEND:    EQU    080H            ; END
ZFOR:    EQU    081H            ; FOR
ZDATA:    EQU    083H            ; DATA
ZGOTO:    EQU    088H            ; GOTO
ZGOSUB:  EQU    08CH            ; GOSUB
ZREM:    EQU    08EH            ; REM
ZPRINT:  EQU    09EH            ; PRINT
ZNEW:    EQU    0A4H            ; NEW

ZTAB:    EQU    0A5H            ; TAB
ZTO:     EQU    0A6H            ; TO
ZFN:     EQU    0A7H            ; FN
ZSPC:    EQU    0A8H            ; SPC
ZTHEN:    EQU    0A9H            ; THEN
ZNOT:    EQU    0AAH            ; NOT
ZSTEP:    EQU    0ABH            ; STEP

ZPLUS:    EQU    0ACH            ; +
ZMINUS:  EQU    0ADH            ; -
ZTIMES:  EQU    0AEH            ; *
ZDIV:    EQU    0AFH            ; /
ZOR:     EQU    0B2H            ; OR
ZGTR:    EQU    0B3H            ; >
ZEQUAL:  EQU    0B4H            ; M
ZLTH:    EQU    0B5H            ; <
ZSGN:    EQU    0B6H            ; SGN
ZPOINT:  EQU    0C7H            ; POINT
ZLEFT:    EQU    0CDH +2         ; LEFT$

; ARITHMETIC PRECEDENCE TABLE

PRITAB: .BYTE   79H             ; Precedence value
        .WORD   PADD            ; FPREG = <last> + FPREG

        .BYTE   79H             ; Precedence value
        .WORD   PSUB            ; FPREG = <last> - FPREG

        .BYTE   7CH             ; Precedence value
        .WORD   MULT            ; PPREG = <last> * FPREG

        .BYTE   7CH             ; Precedence value
        .WORD   DIV             ; FPREG = <last> / FPREG

        .BYTE   7FH             ; Precedence value
        .WORD   POWER           ; FPREG = <last> ^ FPREG

        .BYTE   50H             ; Precedence value
        .WORD   PAND            ; FPREG = <last> AND FPREG

        .BYTE   46H             ; Precedence value
        .WORD   POR             ; FPREG = <last> OR FPREG

; BASIC ERROR CODE LIST

ERRORS: .BYTE   "NF"            ; NEXT without FOR
        .BYTE   "SN"            ; Syntax error
        .BYTE   "RG"            ; RETURN without GOSUB
        .BYTE   "OD"            ; Out of DATA
        .BYTE   "FC"            ; Illegal function call
        .BYTE   "OV"            ; Overflow error
        .BYTE   "OM"            ; Out of memory
        .BYTE   "UL"            ; Undefined line
        .BYTE   "BS"            ; Bad subscript
        .BYTE   "DD"            ; Re-DIMensioned array
        .BYTE   "/0"            ; Division by zero
        .BYTE   "ID"            ; Illegal direct
        .BYTE   "TM"            ; Type mis-match
        .BYTE   "OS"            ; Out of string space
        .BYTE   "LS"            ; String too long
        .BYTE   "ST"            ; String formula too complex
        .BYTE   "CN"            ; Can't CONTinue
        .BYTE   "UF"            ; Undefined FN function
        .BYTE   "MO"            ; Missing operand
        .BYTE   "HX"            ; HEX error
        .BYTE   "BN"            ; BIN error

; INITIALISATION TABLE -------------------------------------------------------

INITAB: JP      WARMST          ; Warm start jump
        JP      FCERR           ; "USR (X)" jump (Set to Error)
        OUT     (0),A           ; "OUT p,n" skeleton
        RET
        SUB     0               ; Division support routine
        ld      L,A
        ld      A,H
        SBC     A,0
        ld      H,A
        ld      A,B
        SBC     A,0
        ld      B,A
        ld      A,0
        RET
        .BYTE   0,0,0                   ; Random number seed table used by RND
        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
        .BYTE   052H,0C7H,04FH,080H     ; Last random number
        IN      A,(0)           ; INP (x) skeleton
        RET
        .BYTE   1               ; POS (x) number (1)
        .BYTE   255             ; Terminal width (255 = no auto CRLF)
        .BYTE   28              ; Width for commas (3 columns)
        .BYTE   0               ; No nulls after input bytes
        .BYTE   0               ; Output enabled (^O off)
        .WORD   20              ; Initial lines counter
        .WORD   20              ; Initial lines number
        .WORD   0               ; Array load/save check sum
        .BYTE   0               ; Break not by NMI
        .BYTE   0               ; Break flag
        JP      TTYLIN          ; Input reflection (set to TTY)
        JP      $0000           ; POINT reflection unused
        JP      $0000           ; SET reflection
        JP      $0000          	; RESET reflection
        .WORD   STLOOK          ; Temp string space
        .WORD   -2              ; Current line number (cold)
        .WORD   PROGST+1        ; Start of program text
INITBE:                         

; END OF INITIALISATION TABLE ---------------------------------------------------

ERRMSG: .BYTE   " Error",0
INMSG:  .BYTE   " in ",0
ZERBYT:  EQU    $-1             ; A zero byte
OKMSG:  .BYTE   "Ok",CR,LF,0,0
BRKMSG: .BYTE   "Break",0

BAKSTK: ld      HL,4            ; Look for "FOR" block with
        ADD     HL,SP           ; same index as specified
LOKFOR: ld      A,(HL)          ; Get block ID
        INC     HL              ; Point to index address
        CP      ZFOR            ; Is it a "FOR" token
        RET     NZ              ; No - exit
        ld      C,(HL)          ; BC = Address of "FOR" index
        INC     HL
        ld      B,(HL)
        INC     HL              ; Point to sign of STEP
        PUSH    HL              ; Save pointer to sign
        ld      L,C             ; HL = address of "FOR" index
        ld      H,B
        ld      A,D             ; See if an index was specified
        OR      E               ; DE = 0 if no index specified
        EX      DE,HL           ; Specified index into HL
        JP      Z,INDFND        ; Skip if no index given
        EX      DE,HL           ; Index back into DE
        CALL    CPDEHL          ; Compare index with one given
INDFND: ld      BC,16-3         ; Offset to next block
        POP     HL              ; Restore pointer to sign
        RET     Z               ; Return if block found
        ADD     HL,BC           ; Point to next block
        JP      LOKFOR          ; Keep on looking

MOVUP:  CALL    ENFMEM          ; See if enough memory
MOVSTR: PUSH    BC              ; Save end of source
        EX      (SP),HL         ; Swap source and dest" end
        POP     BC              ; Get end of destination
MOVLP:  CALL    CPDEHL          ; See if list moved
        ld      A,(HL)          ; Get byte
        ld      (BC),A          ; Move it
        RET     Z               ; Exit if all done
        DEC     BC              ; Next byte to move to
        DEC     HL              ; Next byte to move
        JP      MOVLP           ; Loop until all bytes moved

CHKSTK: PUSH    HL              ; Save code string address
        ld      HL,(ARREND)     ; Lowest free memory
        ld      B,0             ; BC = Number of levels to test
        ADD     HL,BC           ; 2 Bytes for each level
        ADD     HL,BC
        .BYTE   3EH             ; Skip "PUSH HL"
ENFMEM: PUSH    HL              ; Save code string address
        ld      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
        SUB     L
        ld      L,A
        ld      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
        SBC     A,H
        JP      C,OMERR         ; Not enough - ?OM Error
        ld      H,A
        ADD     HL,SP           ; Test if stack is overflowed
        POP     HL              ; Restore code string address
        RET     C               ; Return if enough mmory
OMERR:  ld      E,OM            ; ?OM Error
        JP      ERROR

DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
        ld      (LINEAT),HL     ; Save as current line
SNERR:  ld      E,SN            ; ?SN Error
        .BYTE   01H             ; Skip "ld E,DZ"
DZERR:  ld      E,DZ            ; ?/0 Error
        .BYTE   01H             ; Skip "ld E,NF"
NFERR:  ld      E,NF            ; ?NF Error
        .BYTE   01H             ; Skip "ld E,DD"
DDERR:  ld      E,DD            ; ?DD Error
        .BYTE   01H             ; Skip "ld E,UF"
UFERR:  ld      E,UF            ; ?UF Error
        .BYTE   01H             ; Skip "ld E,OV
OVERR:  ld      E,OV            ; ?OV Error
        .BYTE   01H             ; Skip "ld E,TM"
TMERR:  ld      E,TM            ; ?TM Error

ERROR:  CALL    CLREG           ; Clear registers and stack
        ld      (CTLOFG),A      ; Enable output (A is 0)
        CALL    STTLIN          ; Start new line
        ld      HL,ERRORS       ; Point to error codes
        ld      D,A             ; D = 0 (A is 0)
        ld      A,'?'
        CALL    OUTC            ; Output '?'
        ADD     HL,DE           ; Offset to correct error code
        ld      A,(HL)          ; First character
        CALL    OUTC            ; Output it
        CALL    GETCHR          ; Get next character
        CALL    OUTC            ; Output it
        ld      HL,ERRMSG       ; "Error" message
ERRIN:  CALL    PRS             ; Output message
        ld      HL,(LINEAT)     ; Get line of error
        ld      DE,-2           ; Cold start error if -2
        CALL    CPDEHL          ; See if cold start error
        JP      Z,CSTART        ; Cold start error - Restart
        ld      A,H             ; Was it a direct error?
        AND     L               ; Line = -1 if direct error
        INC     A
        CALL    NZ,LINEIN       ; No - output line of error
        .BYTE   3EH             ; Skip "POP BC"
POPNOK: POP     BC              ; Drop address in input buffer

PRNTOK: XOR     A               ; Output "Ok" and get command
        ld      (CTLOFG),A      ; Enable output
        CALL    STTLIN          ; Start new line
        ld      HL,OKMSG        ; "Ok" message
        CALL    PRS             ; Output "Ok"
GETCMD: ld      HL,-1           ; Flag direct mode
        ld      (LINEAT),HL     ; Save as current line
        CALL    GETLIN          ; Get an input line
        JP      C,GETCMD        ; Get line again if break
        CALL    GETCHR          ; Get first character
        INC     A               ; Test if end of line
        DEC     A               ; Without affecting Carry
        JP      Z,GETCMD        ; Nothing entered - Get another
        PUSH    AF              ; Save Carry status
        CALL    ATOH            ; Get line number into DE
        PUSH    DE              ; Save line number
        CALL    CRUNCH          ; Tokenise rest of line
        ld      B,A             ; Length of tokenised line
        POP     DE              ; Restore line number
        POP     AF              ; Restore Carry
        JP      NC,EXCUTE       ; No line number - Direct mode
        PUSH    DE              ; Save line number
        PUSH    BC              ; Save length of tokenised line
        XOR     A
        ld      (LSTBIN),A      ; Clear last byte input
        CALL    GETCHR          ; Get next character
        OR      A               ; Set flags
        PUSH    AF              ; And save them
        CALL    SRCHLN          ; Search for line number in DE
        JP      C,LINFND        ; Jump if line found
        POP     AF              ; Get status
        PUSH    AF              ; And re-save
        JP      Z,ULERR         ; Nothing after number - Error
        OR      A               ; Clear Carry
LINFND: PUSH    BC              ; Save address of line in prog
        JP      NC,INEWLN       ; Line not found - Insert new
        EX      DE,HL           ; Next line address in DE
        ld      HL,(PROGND)     ; End of program
SFTPRG: ld      A,(DE)          ; Shift rest of program down
        ld      (BC),A
        INC     BC              ; Next destination
        INC     DE              ; Next source
        CALL    CPDEHL          ; All done?
        JP      NZ,SFTPRG       ; More to do
        ld      H,B             ; HL - New end of program
        ld      L,C
        ld      (PROGND),HL     ; Update end of program

INEWLN: POP     DE              ; Get address of line,
        POP     AF              ; Get status
        JP      Z,SETPTR        ; No text - Set up pointers
        ld      HL,(PROGND)     ; Get end of program
        EX      (SP),HL         ; Get length of input line
        POP     BC              ; End of program to BC
        ADD     HL,BC           ; Find new end
        PUSH    HL              ; Save new end
        CALL    MOVUP           ; Make space for line
        POP     HL              ; Restore new end
        ld      (PROGND),HL     ; Update end of program pointer
        EX      DE,HL           ; Get line to move up in HL
        ld      (HL),H          ; Save MSB
        POP     DE              ; Get new line number
        INC     HL              ; Skip pointer
        INC     HL
        ld      (HL),E          ; Save LSB of line number
        INC     HL
        ld      (HL),D          ; Save MSB of line number
        INC     HL              ; To first byte in line
        ld      DE,BUFFER       ; Copy buffer to program
MOVBUF: ld      A,(DE)          ; Get source
        ld      (HL),A          ; Save destinations
        INC     HL              ; Next source
        INC     DE              ; Next destination
        OR      A               ; Done?
        JP      NZ,MOVBUF       ; No - Repeat
SETPTR: CALL    RUNFST          ; Set line pointers
        INC     HL              ; To LSB of pointer
        EX      DE,HL           ; Address to DE
PTRLP:  ld      H,D             ; Address to HL
        ld      L,E
        ld      A,(HL)          ; Get LSB of pointer
        INC     HL              ; To MSB of pointer
        OR      (HL)            ; Compare with MSB pointer
        JP      Z,GETCMD        ; Get command line if end
        INC     HL              ; To LSB of line number
        INC     HL              ; Skip line number
        INC     HL              ; Point to first byte in line
        XOR     A               ; Looking for 00 byte
FNDEND: CP      (HL)            ; Found end of line?
        INC     HL              ; Move to next byte
        JP      NZ,FNDEND       ; No - Keep looking
        EX      DE,HL           ; Next line address to HL
        ld      (HL),E          ; Save LSB of pointer
        INC     HL
        ld      (HL),D          ; Save MSB of pointer
        JP      PTRLP           ; Do next line

SRCHLN: ld      HL,(BASTXT)     ; Start of program text
SRCHLP: ld      B,H             ; BC = Address to look at
        ld      C,L
        ld      A,(HL)          ; Get address of next line
        INC     HL
        OR      (HL)            ; End of program found?
        DEC     HL
        RET     Z               ; Yes - Line not found
        INC     HL
        INC     HL
        ld      A,(HL)          ; Get LSB of line number
        INC     HL
        ld      H,(HL)          ; Get MSB of line number
        ld      L,A
        CALL    CPDEHL          ; Compare with line in DE
        ld      H,B             ; HL = Start of this line
        ld      L,C
        ld      A,(HL)          ; Get LSB of next line address
        INC     HL
        ld      H,(HL)          ; Get MSB of next line address
        ld      L,A             ; Next line to HL
        CCF
        RET     Z               ; Lines found - Exit
        CCF
        RET     NC              ; Line not found,at line after
        JP      SRCHLP          ; Keep looking

NEW:    RET     NZ              ; Return if any more on line
CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
        XOR     A               ; Set program area to empty
        ld      (HL),A          ; Save LSB = 00
        INC     HL
        ld      (HL),A          ; Save MSB = 00
        INC     HL
        ld      (PROGND),HL     ; Set program end

RUNFST: ld      HL,(BASTXT)     ; Clear all variables
        DEC     HL

INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
        ld      HL,(LSTRAM)     ; Get end of RAM
        ld      (STRBOT),HL     ; Clear string space
        XOR     A
        CALL    RESTOR          ; Reset DATA pointers
        ld      HL,(PROGND)     ; Get end of program
        ld      (VAREND),HL     ; Clear variables
        ld      (ARREND),HL     ; Clear arrays

CLREG:  POP     BC              ; Save return address
        ld      HL,(STRSPC)     ; Get end of working RAN
        ld      SP,HL           ; Set stack
        ld      HL,TMSTPL       ; Temporary string pool
        ld      (TMSTPT),HL     ; Reset temporary string ptr
        XOR     A               ; A = 00
        ld      L,A             ; HL = 0000
        ld      H,A
        ld      (CONTAD),HL     ; No CONTinue
        ld      (FORFLG),A      ; Clear FOR flag
        ld      (FNRGNM),HL     ; Clear FN argument
        PUSH    HL              ; HL = 0000
        PUSH    BC              ; Put back return
DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
        RET                     ; Return to execution driver

PROMPT: ld      A,'?'           ; '?'
        CALL    OUTC            ; Output character
        ld      A,' '           ; Space
        CALL    OUTC            ; Output character
; JC TRYING GOING STRAIGHT TO TTYLIN
;        JP TTYLIN
        
        JP      RINPUT          ; Get input line

CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
        ld      (DATFLG),A      ; Reset literal flag
        ld      C,2+3           ; 2 byte number and 3 nulls
        ld      DE,BUFFER       ; Start of input buffer
CRNCLP: ld      A,(HL)          ; Get byte
        CP      ' '             ; Is it a space?
        JP      Z,MOVDIR        ; Yes - Copy direct
        ld      B,A             ; Save character
        CP      022h            ; Is it a quote?
        JP      Z,CPYLIT        ; Yes - Copy literal string
        OR      A               ; Is it end of buffer?
        JP      Z,ENDBUF        ; Yes - End buffer
        ld      A,(DATFLG)      ; Get data type
        OR      A               ; Literal?
        ld      A,(HL)          ; Get byte to copy
        JP      NZ,MOVDIR       ; Literal - Copy direct
        CP      '?'             ; Is it '?' short for PRINT
        ld      A,ZPRINT        ; "PRINT" token
        JP      Z,MOVDIR        ; Yes - replace it
        ld      A,(HL)          ; Get byte again
        CP      '0'             ; Is it less than '0'
        JP      C,FNDWRD        ; Yes - Look for reserved words
        CP      60; ";"+1           ; Is it "0123456789:;" ?
        JP      C,MOVDIR        ; Yes - copy it direct
FNDWRD: PUSH    DE              ; Look for reserved words
        ld      DE,WORDS-1      ; Point to table
        PUSH    BC              ; Save count
        ld      BC,RETNAD       ; Where to return to
        PUSH    BC              ; Save return address
        ld      B,ZEND-1        ; First token value -1
        ld      A,(HL)          ; Get byte
        CP      'a'             ; Less than 'a' ?
        JP      C,SEARCH        ; Yes - search for words
        CP      'z'+1           ; Greater than 'z' ?
        JP      NC,SEARCH       ; Yes - search for words
        AND     01011111B       ; Force upper case
        ld      (HL),A          ; Replace byte
SEARCH: ld      C,(HL)          ; Search for a word
        EX      DE,HL
GETNXT: INC     HL              ; Get next reserved word
        OR      (HL)            ; Start of word?
        JP      P,GETNXT        ; No - move on
        INC     B               ; Increment token value
        ld      A, (HL)         ; Get byte from table
        AND     01111111B       ; Strip bit 7
        RET     Z               ; Return if end of list
        CP      C               ; Same character as in buffer?
        JP      NZ,GETNXT       ; No - get next word
        EX      DE,HL
        PUSH    HL              ; Save start of word

NXTBYT: INC     DE              ; Look through rest of word
        ld      A,(DE)          ; Get byte from table
        OR      A               ; End of word ?
        JP      M,MATCH         ; Yes - Match found
        ld      C,A             ; Save it
        ld      A,B             ; Get token value
        CP      ZGOTO           ; Is it "GOTO" token ?
        JP      NZ,NOSPC        ; No - Don't allow spaces
        CALL    GETCHR          ; Get next character
        DEC     HL              ; Cancel increment from GETCHR
NOSPC:  INC     HL              ; Next byte
        ld      A,(HL)          ; Get byte
        CP      'a'             ; Less than 'a' ?
        JP      C,NOCHNG        ; Yes - don't change
        AND     01011111B       ; Make upper case
NOCHNG: CP      C               ; Same as in buffer ?
        JP      Z,NXTBYT        ; Yes - keep testing
        POP     HL              ; Get back start of word
        JP      SEARCH          ; Look at next word

MATCH:  ld      C,B             ; Word found - Save token value
        POP     AF              ; Throw away return
        EX      DE,HL
        RET                     ; Return to "RETNAD"
RETNAD: EX      DE,HL           ; Get address in string
        ld      A,C             ; Get token value
        POP     BC              ; Restore buffer length
        POP     DE              ; Get destination address
MOVDIR: INC     HL              ; Next source in buffer
        ld      (DE),A          ; Put byte in buffer
        INC     DE              ; Move up buffer
        INC     C               ; Increment length of buffer
        SUB     ':'             ; End of statement?
        JP      Z,SETLIT        ; Jump if multi-statement line
        CP      ZDATA-3AH       ; Is it DATA statement ?
        JP      NZ,TSTREM       ; No - see if REM
SETLIT: ld      (DATFLG),A      ; Set literal flag
TSTREM: SUB     ZREM-3AH        ; Is it REM?
        JP      NZ,CRNCLP       ; No - Leave flag
        ld      B,A             ; Copy rest of buffer
NXTCHR: ld      A,(HL)          ; Get byte
        OR      A               ; End of line ?
        JP      Z,ENDBUF        ; Yes - Terminate buffer
        CP      B               ; End of statement ?
        JP      Z,MOVDIR        ; Yes - Get next one
CPYLIT: INC     HL              ; Move up source string
        ld      (DE),A          ; Save in destination
        INC     C               ; Increment length
        INC     DE              ; Move up destination
        JP      NXTCHR          ; Repeat

ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
        ld      (DE),A          ; Mark end of buffer (A = 00)
        INC     DE
        ld      (DE),A          ; A = 00
        INC     DE
        ld      (DE),A          ; A = 00
        RET

DODEL:  ld      A,(NULFLG)      ; Get null flag status
        OR      A               ; Is it zero?
        ld      A,0             ; Zero A - Leave flags
        ld      (NULFLG),A      ; Zero null flag
        JP      NZ,ECHDEL       ; Set - Echo it
        DEC     B               ; Decrement length
        JP      Z,GETLIN        ; Get line again if empty
        CALL    OUTC            ; Output null character
        .BYTE   3EH             ; Skip "DEC B"
ECHDEL: DEC     B               ; Count bytes in buffer
        DEC     HL              ; Back space buffer
        JP      Z,OTKLN         ; No buffer - Try again
        ld      A,(HL)          ; Get deleted byte
        CALL    OUTC            ; Echo it
        JP      MORINP          ; Get more input

DELCHR: DEC     B               ; Count bytes in buffer
        DEC     HL              ; Back space buffer
        CALL    OUTC            ; Output character in A
        JP      NZ,MORINP       ; Not end - Get more
OTKLN:  CALL    OUTC            ; Output character in A
KILIN:  CALL    PRNTCRLF        ; Output CRLF
        JP      TTYLIN          ; Get line again

GETLIN:
TTYLIN: ld      HL,BUFFER       ; Get a line by character
        ld      B,1             ; Set buffer as empty
        XOR     A
        ld      (NULFLG),A      ; Clear null flag
MORINP: CALL    CLOTST          ; Get character and test ^O
        ld      C,A             ; Save character in C
        CP      DEL             ; Delete character?
        JP      Z,DODEL         ; Yes - Process it
        ld      A,(NULFLG)      ; Get null flag
        OR      A               ; Test null flag status
        JP      Z,PROCES        ; Reset - Process character
        ld      A,0             ; Set a null
        CALL    OUTC            ; Output null
        XOR     A               ; Clear A
        ld      (NULFLG),A      ; Reset null flag
PROCES: ld      A,C             ; Get character
        CP      CTRLG           ; Bell?
        JP      Z,PUTCTL        ; Yes - Save it
        CP      CTRLC           ; Is it control "C"?
        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
        SCF                     ; Flag break
        RET     Z               ; Return if control "C"
        CP      CR              ; Is it enter?
        JP      Z,ENDINP        ; Yes - Terminate input
        CP      CTRLU           ; Is it control "U"?
        JP      Z,KILIN         ; Yes - Get another line
        CP      '@'             ; Is it "kill line"?
        JP      Z,OTKLN         ; Yes - Kill line
        CP      '_'             ; Is it delete?
        JP      Z,DELCHR        ; Yes - Delete character
        CP      BKSP            ; Is it backspace?
        JP      Z,DELCHR        ; Yes - Delete character
        CP      CTRLR           ; Is it control "R"?
        JP      NZ,PUTBUF       ; No - Put in buffer
        PUSH    BC              ; Save buffer length
        PUSH    DE              ; Save DE
        PUSH    HL              ; Save buffer address
        ld      (HL),0          ; Mark end of buffer
        CALL    OUTNCR          ; Output and do CRLF
        ld      HL,BUFFER       ; Point to buffer start
        CALL    PRS             ; Output buffer
        POP     HL              ; Restore buffer address
        POP     DE              ; Restore DE
        POP     BC              ; Restore buffer length
        JP      MORINP          ; Get another character

PUTBUF: CP      ' '             ; Is it a control code?
        JP      C,MORINP        ; Yes - Ignore
PUTCTL: ld      A,B             ; Get number of bytes in buffer
        CP      72+1            ; Test for line overflow
        ld      A,CTRLG         ; Set a bell
        JP      NC,OUTNBS       ; Ring bell if buffer full
        ld      A,C             ; Get character
        ld      (HL),C          ; Save in buffer
        ld      (LSTBIN),A      ; Save last input byte
        INC     HL              ; Move up buffer
        INC     B               ; Increment length
OUTIT:  CALL    OUTC            ; Output the character entered
        JP      MORINP          ; Get another character

OUTNBS: CALL    OUTC            ; Output bell and back over it
        ld      A,BKSP          ; Set back space
        JP      OUTIT           ; Output it and get more

CPDEHL: ld      A,H             ; Get H
        SUB     D               ; Compare with D
        RET     NZ              ; Different - Exit
        ld      A,L             ; Get L
        SUB     E               ; Compare with E
        RET                     ; Return status

CHKSYN: ld      A,(HL)          ; Check syntax of character
        EX      (SP),HL         ; Address of test byte
        CP      (HL)            ; Same as in code string?
        INC     HL              ; Return address
        EX      (SP),HL         ; Put it back
        JP      Z,GETCHR        ; Yes - Get next character
        JP      SNERR           ; Different - ?SN Error

OUTC:   PUSH    AF              ; Save character
        ld      A,(CTLOFG)      ; Get control "O" flag
        OR      A               ; Is it set?
        JP      NZ,POPAF        ; Yes - don't output
        POP     AF              ; Restore character
        PUSH    BC              ; Save buffer length
        PUSH    AF              ; Save character
        CP      ' '             ; Is it a control code?
        JP      C,DINPOS        ; Yes - Don't INC POS(X)
        ld      A,(LWIDTH)      ; Get line width
        ld      B,A             ; To B
        ld      A,(CURPOS)      ; Get cursor position
        INC     B               ; Width 255?
        JP      Z,INCLEN        ; Yes - No width limit
        DEC     B               ; Restore width
        CP      B               ; At end of line?
        CALL    Z,PRNTCRLF      ; Yes - output CRLF
INCLEN: INC     A               ; Move on one character
        ld      (CURPOS),A      ; Save new position
DINPOS: POP     AF              ; Restore character
        POP     BC              ; Restore buffer length
        CALL    MONOUT          ; Send it
        RET

CLOTST: CALL    GETINP          ; Get input character
        AND     01111111B       ; Strip bit 7
        CP      CTRLO           ; Is it control "O"?
        RET     NZ              ; No don't flip flag
        ld      A,(CTLOFG)      ; Get flag
        CPL                     ; Flip it
        ld      (CTLOFG),A      ; Put it back
        XOR     A               ; Null character
        RET

LIST:   CALL    ATOH            ; ASCII number to DE
        RET     NZ              ; Return if anything extra
        POP     BC              ; Rubbish - Not needed
        CALL    SRCHLN          ; Search for line number in DE
        PUSH    BC              ; Save address of line
        CALL    SETLIN          ; Set up lines counter
LISTLP: POP     HL              ; Restore address of line
        ld      C,(HL)          ; Get LSB of next line
        INC     HL
        ld      B,(HL)          ; Get MSB of next line
        INC     HL
        ld      A,B             ; BC = 0 (End of program)?
        OR      C
        JP      Z,PRNTOK        ; Yes - Go to command mode
        CALL    COUNT           ; Count lines
        CALL    TSTBRK          ; Test for break key
        PUSH    BC              ; Save address of next line
        CALL    PRNTCRLF        ; Output CRLF
        ld      E,(HL)          ; Get LSB of line number
        INC     HL
        ld      D,(HL)          ; Get MSB of line number
        INC     HL
        PUSH    HL              ; Save address of line start
        EX      DE,HL           ; Line number to HL
        CALL    PRNTHL          ; Output line number in decimal
        ld      A,' '           ; Space after line number
        POP     HL              ; Restore start of line address
LSTLP2: CALL    OUTC            ; Output character in A
LSTLP3: ld      A,(HL)          ; Get next byte in line
        OR      A               ; End of line?
        INC     HL              ; To next byte in line
        JP      Z,LISTLP        ; Yes - get next line
        JP      P,LSTLP2        ; No token - output it
        SUB     ZEND-1          ; Find and output word
        ld      C,A             ; Token offset+1 to C
        ld      DE,WORDS        ; Reserved word list
FNDTOK: ld      A,(DE)          ; Get character in list
        INC     DE              ; Move on to next
        OR      A               ; Is it start of word?
        JP      P,FNDTOK        ; No - Keep looking for word
        DEC     C               ; Count words
        JP      NZ,FNDTOK       ; Not there - keep looking
OUTWRD: AND     01111111B       ; Strip bit 7
        CALL    OUTC            ; Output first character
        ld      A,(DE)          ; Get next character
        INC     DE              ; Move on to next
        OR      A               ; Is it end of word?
        JP      P,OUTWRD        ; No - output the rest
        JP      LSTLP3          ; Next byte in line

SETLIN: PUSH    HL              ; Set up LINES counter
        ld      HL,(LINESN)     ; Get LINES number
        ld      (LINESC),HL     ; Save in LINES counter
        POP     HL
        RET

COUNT:  PUSH    HL              ; Save code string address
        PUSH    DE
        ld      HL,(LINESC)     ; Get LINES counter
        ld      DE,-1
        ADC     HL,DE           ; Decrement
        ld      (LINESC),HL     ; Put it back
        POP     DE
        POP     HL              ; Restore code string address
        RET     P               ; Return if more lines to go
        PUSH    HL              ; Save code string address
        ld      HL,(LINESN)     ; Get LINES number
        ld      (LINESC),HL     ; Reset LINES counter
        CALL    GETINP          ; Get input character
        CP      CTRLC           ; Is it control "C"?
        JP      Z,RSLNBK        ; Yes - Reset LINES and break
        POP     HL              ; Restore code string address
        JP      COUNT           ; Keep on counting

RSLNBK: ld      HL,(LINESN)     ; Get LINES number
        ld      (LINESC),HL     ; Reset LINES counter
        JP      BRKRET          ; Go and output "Break"

FOR:    ld      A,64H           ; Flag "FOR" assignment
        ld      (FORFLG),A      ; Save "FOR" flag
        CALL    LET             ; Set up initial index
        POP     BC              ; Drop RETurn address
        PUSH    HL              ; Save code string address
        CALL    DATA            ; Get next statement address
        ld      (LOOPST),HL     ; Save it for start of loop
        ld      HL,2            ; Offset for "FOR" block
        ADD     HL,SP           ; Point to it
FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
        POP     DE              ; Get code string address
        JP      NZ,FORFND       ; No nesting found
        ADD     HL,BC           ; Move into "FOR" block
        PUSH    DE              ; Save code string address
        DEC     HL
        ld      D,(HL)          ; Get MSB of loop statement
        DEC     HL
        ld      E,(HL)          ; Get LSB of loop statement
        INC     HL
        INC     HL
        PUSH    HL              ; Save block address
        ld      HL,(LOOPST)     ; Get address of loop statement
        CALL    CPDEHL          ; Compare the FOR loops
        POP     HL              ; Restore block address
        JP      NZ,FORSLP       ; Different FORs - Find another
        POP     DE              ; Restore code string address
        ld      SP,HL           ; Remove all nested loops

FORFND: EX      DE,HL           ; Code string address to HL
        ld      C,8
        CALL    CHKSTK          ; Check for 8 levels of stack
        PUSH    HL              ; Save code string address
        ld      HL,(LOOPST)     ; Get first statement of loop
        EX      (SP),HL         ; Save and restore code string
        PUSH    HL              ; Re-save code string address
        ld      HL,(LINEAT)     ; Get current line number
        EX      (SP),HL         ; Save and restore code string
        CALL    TSTNUM          ; Make sure it's a number
        CALL    CHKSYN          ; Make sure "TO" is next
        .BYTE   ZTO          ; "TO" token
        CALL    GETNUM          ; Get "TO" expression value
        PUSH    HL              ; Save code string address
        CALL    BCDEFP          ; Move "TO" value to BCDE
        POP     HL              ; Restore code string address
        PUSH    BC              ; Save "TO" value in block
        PUSH    DE
        ld      BC,8100H        ; BCDE - 1 (default STEP)
        ld      D,C             ; C=0
        ld      E,D             ; D=0
        ld      A,(HL)          ; Get next byte in code string
        CP      ZSTEP           ; See if "STEP" is stated
        ld      A,1             ; Sign of step = 1
        JP      NZ,SAVSTP       ; No STEP given - Default to 1
        CALL    GETCHR          ; Jump over "STEP" token
        CALL    GETNUM          ; Get step value
        PUSH    HL              ; Save code string address
        CALL    BCDEFP          ; Move STEP to BCDE
        CALL    TSTSGN          ; Test sign of FPREG
        POP     HL              ; Restore code string address
SAVSTP: PUSH    BC              ; Save the STEP value in block
        PUSH    DE
        PUSH    AF              ; Save sign of STEP
        INC     SP              ; Don't save flags
        PUSH    HL              ; Save code string address
        ld      HL,(BRKLIN)     ; Get address of index variable
        EX      (SP),HL         ; Save and restore code string
PUTFID: ld      B,ZFOR          ; "FOR" block marker
        PUSH    BC              ; Save it
        INC     SP              ; Don't save C

RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
        ld      (BRKLIN),HL     ; Save code address for break
        ld      A,(HL)          ; Get next byte in code string
        CP      ':'             ; Multi statement line?
        JP      Z,EXCUTE        ; Yes - Execute it
        OR      A               ; End of line?
        JP      NZ,SNERR        ; No - Syntax error
        INC     HL              ; Point to address of next line
        ld      A,(HL)          ; Get LSB of line pointer
        INC     HL
        OR      (HL)            ; Is it zero (End of prog)?
        JP      Z,ENDPRG        ; Yes - Terminate execution
        INC     HL              ; Point to line number
        ld      E,(HL)          ; Get LSB of line number
        INC     HL
        ld      D,(HL)          ; Get MSB of line number
        EX      DE,HL           ; Line number to HL
        ld      (LINEAT),HL     ; Save as current line number
        EX      DE,HL           ; Line number back to DE
EXCUTE: CALL    GETCHR          ; Get key word
        ld      DE,RUNCNT       ; Where to RETurn to
        PUSH    DE              ; Save for RETurn
IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
ONJMP:  SUB     ZEND            ; Is it a token?
        JP      C,LET           ; No - try to assign it
        CP      ZNEW+1-ZEND     ; END to NEW ?
        JP      NC,SNERR        ; Not a key word - ?SN Error
        RLCA                    ; Double it
        ld      C,A             ; BC = Offset into table
        ld      B,0
        EX      DE,HL           ; Save code string address
        ld      HL,WORDTB       ; Keyword address table
        ADD     HL,BC           ; Point to routine address
        ld      C,(HL)          ; Get LSB of routine address
        INC     HL
        ld      B,(HL)          ; Get MSB of routine address
        PUSH    BC              ; Save routine address
        EX      DE,HL           ; Restore code string address

GETCHR: INC     HL              ; Point to next character
        ld      A,(HL)          ; Get next code string byte


; JC TRYING GET SINGLE CHARACTER FROM SERIAL (HACK) THIS NEEDS TO BE REMOVED I THINK
;testserial:
;        in0a    STAT0
;        and 10000000b
;        jr  z, testserial
;        in0a     RDR0
        
        
        CP      ':'             ; Z if ':'
        RET     NC              ; NC if > "9"
        CP      ' '
        JP      Z,GETCHR        ; Skip over spaces
        CP      '0'
        CCF                     ; NC if < '0'
        INC     A               ; Test for zero - Leave carry
        DEC     A               ; Z if Null
        RET

RESTOR: EX      DE,HL           ; Save code string address
        ld      HL,(BASTXT)     ; Point to start of program
        JP      Z,RESTNL        ; Just RESTORE - reset pointer
        EX      DE,HL           ; Restore code string address
        CALL    ATOH            ; Get line number to DE
        PUSH    HL              ; Save code string address
        CALL    SRCHLN          ; Search for line number in DE
        ld      H,B             ; HL = Address of line
        ld      L,C
        POP     DE              ; Restore code string address
        JP      NC,ULERR        ; ?UL Error if not found
RESTNL: DEC     HL              ; Byte before DATA statement
UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
        EX      DE,HL           ; Restore code string address
        RET


TSTBRK:
        CALL    check_serial1in ; JC replacing next line
;        RST     18H            ; Check input status
        RET     Z               ; No key, go back
        CALL    chin            ;JC replacing next line
;        RST     10H             ; Get the key into A
        CP      ESC             ; Escape key?
        JR      Z,BRK           ; Yes, break
        CP      CTRLC           ; <Ctrl-C>
        JR      Z,BRK           ; Yes, break
        CP      CTRLS           ; Stop scrolling?
        RET     NZ              ; Other key, ignore


STALL:  
        CALL    chin            ;JC replacing next line
       ; RST     10H             ; Wait for key
        CP      CTRLQ           ; Resume scrolling?
        RET      Z              ; Release the chokehold
        CP      CTRLC           ; Second break?
        JR      Z,STOP          ; Break during hold exits prog
        JR      STALL           ; Loop until <Ctrl-Q> or <brk>

BRK     ld      A,$FF           ; Set BRKFLG
        ld      (BRKFLG),A      ; Store it


STOP:   RET     NZ              ; Exit if anything else
        .BYTE   0F6H            ; Flag "STOP"
PEND:   RET     NZ              ; Exit if anything else
        ld      (BRKLIN),HL     ; Save point of break
        .BYTE   21H             ; Skip "OR 11111111B"
INPBRK: OR      11111111B       ; Flag "Break" wanted
        POP     BC              ; Return not needed and more
ENDPRG: ld      HL,(LINEAT)     ; Get current line number
        PUSH    AF              ; Save STOP / END status
        ld      A,L             ; Is it direct break?
        AND     H
        INC     A               ; Line is -1 if direct break
        JP      Z,NOLIN         ; Yes - No line number
        ld      (ERRLIN),HL     ; Save line of break
        ld      HL,(BRKLIN)     ; Get point of break
        ld      (CONTAD),HL     ; Save point to CONTinue
NOLIN:  XOR     A
        ld      (CTLOFG),A      ; Enable output
        CALL    STTLIN          ; Start a new line
        POP     AF              ; Restore STOP / END status
        ld      HL,BRKMSG       ; "Break" message
        JP      NZ,ERRIN        ; "in line" wanted?
        JP      PRNTOK          ; Go to command mode

CONT:   ld      HL,(CONTAD)     ; Get CONTinue address
        ld      A,H             ; Is it zero?
        OR      L
        ld      E,CN            ; ?CN Error
        JP      Z,ERROR         ; Yes - output "?CN Error"
        EX      DE,HL           ; Save code string address
        ld      HL,(ERRLIN)     ; Get line of last break
        ld      (LINEAT),HL     ; Set up current line number
        EX      DE,HL           ; Restore code string address
        RET                     ; CONTinue where left off

NULL:   CALL    GETINT          ; Get integer 0-255
        RET     NZ              ; Return if bad value
        ld      (NULLS),A       ; Set nulls number
        RET


ACCSUM: PUSH    HL              ; Save address in array
        ld      HL,(CHKSUM)     ; Get check sum
        ld      B,0             ; BC - Value of byte
        ld      C,A
        ADD     HL,BC           ; Add byte to check sum
        ld      (CHKSUM),HL     ; Re-save check sum
        POP     HL              ; Restore address in array
        RET

CHKLTR: ld      A,(HL)          ; Get byte
        CP      'A'             ; < 'a' ?
        RET     C               ; Carry set if not letter
        CP      'Z'+1           ; > 'z' ?
        CCF
        RET                     ; Carry set if not letter

FPSINT: CALL    GETCHR          ; Get next character
POSINT: CALL    GETNUM          ; Get integer 0 to 32767
DEPINT: CALL    TSTSGN          ; Test sign of FPREG
        JP      M,FCERR         ; Negative - ?FC Error
DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
        CP      80H+16          ; Exponent in range (16 bits)?
        JP      C,FPINT         ; Yes - convert it
        ld      BC,9080H        ; BCDE = -32768
        ld      DE,0000
        PUSH    HL              ; Save code string address
        CALL    CMPNUM          ; Compare FPREG with BCDE
        POP     HL              ; Restore code string address
        ld      D,C             ; MSB to D
        RET     Z               ; Return if in range
FCERR:  ld      E,FC            ; ?FC Error
        JP      ERROR           ; Output error-

ATOH:   DEC     HL              ; ASCII number to DE binary
GETLN:  ld      DE,0            ; Get number to DE
GTLNLP: CALL    GETCHR          ; Get next character
        RET     NC              ; Exit if not a digit
        PUSH    HL              ; Save code string address
        PUSH    AF              ; Save digit
        ld      HL,65529/10     ; Largest number 65529
        CALL    CPDEHL          ; Number in range?
        JP      C,SNERR         ; No - ?SN Error
        ld      H,D             ; HL = Number
        ld      L,E
        ADD     HL,DE           ; Times 2
        ADD     HL,HL           ; Times 4
        ADD     HL,DE           ; Times 5
        ADD     HL,HL           ; Times 10
        POP     AF              ; Restore digit
        SUB     '0'             ; Make it 0 to 9
        ld      E,A             ; DE = Value of digit
        ld      D,0
        ADD     HL,DE           ; Add to number
        EX      DE,HL           ; Number to DE
        POP     HL              ; Restore code string address
        JP      GTLNLP          ; Go to next character

CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
        CALL    POSINT          ; Get integer 0 to 32767 to DE
        DEC     HL              ; Cancel increment
        CALL    GETCHR          ; Get next character
        PUSH    HL              ; Save code string address
        ld      HL,(LSTRAM)     ; Get end of RAM
        JP      Z,STORED        ; No value given - Use stored
        POP     HL              ; Restore code string address
        CALL    CHKSYN          ; Check for comma
        .BYTE      ','
        PUSH    DE              ; Save number
        CALL    POSINT          ; Get integer 0 to 32767
        DEC     HL              ; Cancel increment
        CALL    GETCHR          ; Get next character
        JP      NZ,SNERR        ; ?SN Error if more on line
        EX      (SP),HL         ; Save code string address
        EX      DE,HL           ; Number to DE
STORED: ld      A,L             ; Get LSB of new RAM top
        SUB     E               ; Subtract LSB of string space
        ld      E,A             ; Save LSB
        ld      A,H             ; Get MSB of new RAM top
        SBC     A,D             ; Subtract MSB of string space
        ld      D,A             ; Save MSB
        JP      C,OMERR         ; ?OM Error if not enough mem
        PUSH    HL              ; Save RAM top
        ld      HL,(PROGND)     ; Get program end
        ld      BC,40           ; 40 Bytes minimum working RAM
        ADD     HL,BC           ; Get lowest address
        CALL    CPDEHL          ; Enough memory?
        JP      NC,OMERR        ; No - ?OM Error
        EX      DE,HL           ; RAM top to HL
        ld      (STRSPC),HL     ; Set new string space
        POP     HL              ; End of memory to use
        ld      (LSTRAM),HL     ; Set new top of RAM
        POP     HL              ; Restore code string address
        JP      INTVAR          ; Initialise variables

RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
        CALL    INTVAR          ; Initialise variables
        ld      BC,RUNCNT       ; Execution driver loop
        JP      RUNLIN          ; RUN from line number

GOSUB:  ld      C,3             ; 3 Levels of stack needed
        CALL    CHKSTK          ; Check for 3 levels of stack
        POP     BC              ; Get return address
        PUSH    HL              ; Save code string for RETURN
        PUSH    HL              ; And for GOSUB routine
        ld      HL,(LINEAT)     ; Get current line
        EX      (SP),HL         ; Into stack - Code string out
        ld      A,ZGOSUB        ; "GOSUB" token
        PUSH    AF              ; Save token
        INC     SP              ; Don't save flags

RUNLIN: PUSH    BC              ; Save return address
GOTO:   CALL    ATOH            ; ASCII number to DE binary
        CALL    REM             ; Get end of line
        PUSH    HL              ; Save end of line
        ld      HL,(LINEAT)     ; Get current line
        CALL    CPDEHL          ; Line after current?
        POP     HL              ; Restore end of line
        INC     HL              ; Start of next line
        CALL    C,SRCHLP        ; Line is after current line
        CALL    NC,SRCHLN       ; Line is before current line
        ld      H,B             ; Set up code string address
        ld      L,C
        DEC     HL              ; Incremented after
        RET     C               ; Line found
ULERR:  ld      E,UL            ; ?UL Error
        JP      ERROR           ; Output error message

RETURN: RET     NZ              ; Return if not just RETURN
        ld      D,-1            ; Flag "GOSUB" search
        CALL    BAKSTK          ; Look "GOSUB" block
        ld      SP,HL           ; Kill all FORs in subroutine
        CP      ZGOSUB          ; Test for "GOSUB" token
        ld      E,RG            ; ?RG Error
        JP      NZ,ERROR        ; Error if no "GOSUB" found
        POP     HL              ; Get RETURN line number
        ld      (LINEAT),HL     ; Save as current
        INC     HL              ; Was it from direct statement?
        ld      A,H
        OR      L               ; Return to line
        JP      NZ,RETLIN       ; No - Return to line
        ld      A,(LSTBIN)      ; Any INPUT in subroutine?
        OR      A               ; If so buffer is corrupted
        JP      NZ,POPNOK       ; Yes - Go to command mode
RETLIN: ld      HL,RUNCNT       ; Execution driver loop
        EX      (SP),HL         ; Into stack - Code string out
        .BYTE      3EH             ; Skip "POP HL"
NXTDTA: POP     HL              ; Restore code string address

DATA:   .BYTE      01H,3AH         ; ':' End of statement
REM:    ld      C,0             ; 00  End of statement
        ld      B,0
NXTSTL: ld      A,C             ; Statement and byte
        ld      C,B
        ld      B,A             ; Statement end byte
NXTSTT: ld      A,(HL)          ; Get byte
        OR      A               ; End of line?
        RET     Z               ; Yes - Exit
        CP      B               ; End of statement?
        RET     Z               ; Yes - Exit
        INC     HL              ; Next byte
        CP      022h            ; Literal string?
        JP      Z,NXTSTL        ; Yes - Look for another '"'
        JP      NXTSTT          ; Keep looking

LET:    CALL    GETVAR          ; Get variable name
        CALL    CHKSYN          ; Make sure "=" follows
        .BYTE      ZEQUAL          ; "=" token
        PUSH    DE              ; Save address of variable
        ld      A,(TYPE)        ; Get data type
        PUSH    AF              ; Save type
        CALL    EVAL            ; Evaluate expression
        POP     AF              ; Restore type
        EX      (SP),HL         ; Save code - Get var addr
        ld      (BRKLIN),HL     ; Save address of variable
        RRA                     ; Adjust type
        CALL    CHKTYP          ; Check types are the same
        JP      Z,LETNUM        ; Numeric - Move value
LETSTR: PUSH    HL              ; Save address of string var
        ld      HL,(FPREG)      ; Pointer to string entry
        PUSH    HL              ; Save it on stack
        INC     HL              ; Skip over length
        INC     HL
        ld      E,(HL)          ; LSB of string address
        INC     HL
        ld      D,(HL)          ; MSB of string address
        ld      HL,(BASTXT)     ; Point to start of program
        CALL    CPDEHL          ; Is string before program?
        JP      NC,CRESTR       ; Yes - Create string entry
        ld      HL,(STRSPC)     ; Point to string space
        CALL    CPDEHL          ; Is string literal in program?
        POP     DE              ; Restore address of string
        JP      NC,MVSTPT       ; Yes - Set up pointer
        ld      HL,TMPSTR       ; Temporary string pool
        CALL    CPDEHL          ; Is string in temporary pool?
        JP      NC,MVSTPT       ; No - Set up pointer
        .BYTE   3EH             ; Skip "POP DE"
CRESTR: POP     DE              ; Restore address of string
        CALL    BAKTMP          ; Back to last tmp-str entry
        EX      DE,HL           ; Address of string entry
        CALL    SAVSTR          ; Save string in string area
MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
        POP     HL              ; Get string pointer
        CALL    DETHL4          ; Move string pointer to var
        POP     HL              ; Restore code string address
        RET

LETNUM: PUSH    HL              ; Save address of variable
        CALL    FPTHL           ; Move value to variable
        POP     DE              ; Restore address of variable
        POP     HL              ; Restore code string address
        RET

ON:     CALL    GETINT          ; Get integer 0-255
        ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
        ld      B,A             ; Save in B
        CP      ZGOSUB          ; "GOSUB" token?
        JP      Z,ONGO          ; Yes - Find line number
        CALL    CHKSYN          ; Make sure it's "GOTO"
        .BYTE   ZGOTO           ; "GOTO" token
        DEC     HL              ; Cancel increment
ONGO:   ld      C,E             ; Integer of branch value
ONGOLP: DEC     C               ; Count branches
        ld      A,B             ; Get "GOTO" or "GOSUB" token
        JP      Z,ONJMP         ; Go to that line if right one
        CALL    GETLN           ; Get line number to DE
        CP      ','             ; Another line number?
        RET     NZ              ; No - Drop through
        JP      ONGOLP          ; Yes - loop

IF:     CALL    EVAL            ; Evaluate expression
        ld      A,(HL)          ; Get token
        CP      ZGOTO           ; "GOTO" token?
        JP      Z,IFGO          ; Yes - Get line
        CALL    CHKSYN          ; Make sure it's "THEN"
        .BYTE      ZTHEN           ; "THEN" token
        DEC     HL              ; Cancel increment
IFGO:   CALL    TSTNUM          ; Make sure it's numeric
        CALL    TSTSGN          ; Test state of expression
        JP      Z,REM           ; False - Drop through
        CALL    GETCHR          ; Get next character
        JP      C,GOTO          ; Number - GOTO that line
        JP      IFJMP           ; Otherwise do statement

MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
PRNTLP: RET     Z               ; End of list - Exit
        CP      ZTAB            ; "TAB(" token?
        JP      Z,DOTAB         ; Yes - Do TAB routine
        CP      ZSPC            ; "SPC(" token?
        JP      Z,DOTAB         ; Yes - Do SPC routine
        PUSH    HL              ; Save code string address
        CP      ','             ; Comma?
        JP      Z,DOCOM         ; Yes - Move to next zone
        CP      59 ;";"         ; Semi-colon?
        JP      Z,NEXITM        ; Do semi-colon routine
        POP     BC              ; Code string address to BC
        CALL    EVAL            ; Evaluate expression
        PUSH    HL              ; Save code string address
        ld      A,(TYPE)        ; Get variable type
        OR      A               ; Is it a string variable?
        JP      NZ,PRNTST       ; Yes - Output string contents
        CALL    NUMASC          ; Convert number to text
        CALL    CRTST           ; Create temporary string
        ld      (HL),' '        ; Followed by a space
        ld      HL,(FPREG)      ; Get length of output
        INC     (HL)            ; Plus 1 for the space
        ld      HL,(FPREG)      ; < Not needed >
        ld      A,(LWIDTH)      ; Get width of line
        ld      B,A             ; To B
        INC     B               ; Width 255 (No limit)?
        JP      Z,PRNTNB        ; Yes - Output number string
        INC     B               ; Adjust it
        ld      A,(CURPOS)      ; Get cursor position
        ADD     A,(HL)          ; Add length of string
        DEC     A               ; Adjust it
        CP      B               ; Will output fit on this line?
        CALL    NC,PRNTCRLF     ; No - CRLF first
PRNTNB: CALL    PRS1            ; Output string at (HL)
        XOR     A               ; Skip CALL by setting 'z' flag
PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
        POP     HL              ; Restore code string address
        JP      MRPRNT          ; See if more to PRINT

STTLIN: ld      A,(CURPOS)      ; Make sure on new line
        OR      A               ; Already at start?
        RET     Z               ; Yes - Do nothing
        JP      PRNTCRLF        ; Start a new line

ENDINP: ld      (HL),0          ; Mark end of buffer
        ld      HL,BUFFER-1     ; Point to buffer
PRNTCRLF: ld    A,CR            ; Load a CR
        CALL    OUTC            ; Output character
        ld      A,LF            ; Load a LF
        CALL    OUTC            ; Output character
DONULL: XOR     A               ; Set to position 0
        ld      (CURPOS),A      ; Store it
        ld      A,(NULLS)       ; Get number of nulls
NULLP:  DEC     A               ; Count them
        RET     Z               ; Return if done
        PUSH    AF              ; Save count
        XOR     A               ; Load a null
        CALL    OUTC            ; Output it
        POP     AF              ; Restore count
        JP      NULLP           ; Keep counting

DOCOM:  ld      A,(COMMAN)      ; Get comma width
        ld      B,A             ; Save in B
        ld      A,(CURPOS)      ; Get current position
        CP      B               ; Within the limit?
        CALL    NC,PRNTCRLF     ; No - output CRLF
        JP      NC,NEXITM       ; Get next item
ZONELP: SUB     14              ; Next zone of 14 characters
        JP      NC,ZONELP       ; Repeat if more zones
        CPL                     ; Number of spaces to output
        JP      ASPCS           ; Output them

DOTAB:  PUSH    AF              ; Save token
        CALL    FNDNUM          ; Evaluate expression
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE   ")"
        DEC     HL              ; Back space on to ")"
        POP     AF              ; Restore token
        SUB     ZSPC            ; Was it "SPC(" ?
        PUSH    HL              ; Save code string address
        JP      Z,DOSPC         ; Yes - Do 'E' spaces
        ld      A,(CURPOS)      ; Get current position
DOSPC:  CPL                     ; Number of spaces to print to
        ADD     A,E             ; Total number to print
        JP      NC,NEXITM       ; TAB < Current POS(X)
ASPCS:  INC     A               ; Output A spaces
        ld      B,A             ; Save number to print
        ld      A,' '           ; Space
SPCLP:  CALL    OUTC            ; Output character in A
        DEC     B               ; Count them
        JP      NZ,SPCLP        ; Repeat if more
NEXITM: POP     HL              ; Restore code string address
        CALL    GETCHR          ; Get next character
        JP      PRNTLP          ; More to print

REDO:   .BYTE   "?Redo from start",CR,LF,0

BADINP: ld      A,(READFG)      ; READ or INPUT?
        OR      A
        JP      NZ,DATSNR       ; READ - ?SN Error
        POP     BC              ; Throw away code string addr
        ld      HL,REDO         ; "Redo from start" message
        CALL    PRS             ; Output string
        JP      DOAGN           ; Do last INPUT again

INPUT:  CALL    IDTEST          ; Test for illegal direct
        ld      A,(HL)          ; Get character after "INPUT"
        CP      022h            ; Is there a prompt string?
        ld      A,0             ; Clear A and leave flags
        ld      (CTLOFG),A      ; Enable output
        JP      NZ,NOPMPT       ; No prompt - get input
        CALL    QTSTR           ; Get string terminated by '"'
        CALL    CHKSYN          ; Check for ';' after prompt
        .BYTE   ';'
        PUSH    HL              ; Save code string address
        CALL    PRS1            ; Output prompt string
        .BYTE   3EH             ; Skip "PUSH HL"
NOPMPT: PUSH    HL              ; Save code string address
        CALL    PROMPT          ; Get input with "? " prompt
        POP     BC              ; Restore code string address
        JP      C,INPBRK        ; Break pressed - Exit
        INC     HL              ; Next byte
        ld      A,(HL)          ; Get it
        OR      A               ; End of line?
        DEC     HL              ; Back again
        PUSH    BC              ; Re-save code string address
        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
        ld      (HL),','        ; Store comma as separator
        JP      NXTITM          ; Get next item

READ:   PUSH    HL              ; Save code string address
        ld      HL,(NXTDAT)     ; Next DATA statement
        .BYTE   0F6H            ; Flag "READ"
NXTITM: XOR     A               ; Flag "INPUT"
        ld      (READFG),A      ; Save "READ"/"INPUT" flag
        EX      (SP),HL         ; Get code str' , Save pointer
        JP      GTVLUS          ; Get values

NEDMOR: CALL    CHKSYN          ; Check for comma between items
        .BYTE      ','
GTVLUS: CALL    GETVAR          ; Get variable name
        EX      (SP),HL         ; Save code str" , Get pointer
        PUSH    DE              ; Save variable address
        ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
        CP      ','             ; Comma?
        JP      Z,ANTVLU        ; Yes - Get another value
        ld      A,(READFG)      ; Is it READ?
        OR      A
        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
        ld      A,'?'           ; More INPUT needed
        CALL    OUTC            ; Output character
        CALL    PROMPT          ; Get INPUT with prompt
        POP     DE              ; Variable address
        POP     BC              ; Code string address
        JP      C,INPBRK        ; Break pressed
        INC     HL              ; Point to next DATA byte
        ld      A,(HL)          ; Get byte
        OR      A               ; Is it zero (No input) ?
        DEC     HL              ; Back space INPUT pointer
        PUSH    BC              ; Save code string address
        JP      Z,NXTDTA        ; Find end of buffer
        PUSH    DE              ; Save variable address
ANTVLU: ld      A,(TYPE)        ; Check data type
        OR      A               ; Is it numeric?
        JP      Z,INPBIN        ; Yes - Convert to binary
        CALL    GETCHR          ; Get next character
        ld      D,A             ; Save input character
        ld      B,A             ; Again
        CP      022h            ; Start of literal sting?
        JP      Z,STRENT        ; Yes - Create string entry
        ld      A,(READFG)      ; "READ" or "INPUT" ?
        OR      A
        ld      D,A             ; Save 00 if "INPUT"
        JP      Z,ITMSEP        ; "INPUT" - End with 00
        ld      D,':'           ; "DATA" - End with 00 or ':'
ITMSEP: ld      B,','           ; Item separator
        DEC     HL              ; Back space for DTSTR
STRENT: CALL    DTSTR           ; Get string terminated by D
        EX      DE,HL           ; String address to DE
        ld      HL,LTSTND       ; Where to go after LETSTR
        EX      (SP),HL         ; Save HL , get input pointer
        PUSH    DE              ; Save address of string
        JP      LETSTR          ; Assign string to variable

INPBIN: CALL    GETCHR          ; Get next character
        CALL    ASCTFP          ; Convert ASCII to FP number
        EX      (SP),HL         ; Save input ptr, Get var addr
        CALL    FPTHL           ; Move FPREG to variable
        POP     HL              ; Restore input pointer
LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      Z,MORDT         ; End of line - More needed?
        CP      ','             ; Another value?
        JP      NZ,BADINP       ; No - Bad input
MORDT:  EX      (SP),HL         ; Get code string address
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      NZ,NEDMOR       ; More needed - Get it
        POP     DE              ; Restore DATA pointer
        ld      A,(READFG)      ; "READ" or "INPUT" ?
        OR      A
        EX      DE,HL           ; DATA pointer to HL
        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
        PUSH    DE              ; Save code string address
        OR      (HL)            ; More input given?
        ld      HL,EXTIG        ; "?Extra ignored" message
        CALL    NZ,PRS          ; Output string if extra given
        POP     HL              ; Restore code string address
        RET

EXTIG:  .BYTE   "?Extra ignored",CR,LF,0

FDTLP:  CALL    DATA            ; Get next statement
        OR      A               ; End of line?
        JP      NZ,FANDT        ; No - See if DATA statement
        INC     HL
        ld      A,(HL)          ; End of program?
        INC     HL
        OR      (HL)            ; 00 00 Ends program
        ld      E,OD            ; ?OD Error
        JP      Z,ERROR         ; Yes - Out of DATA
        INC     HL
        ld      E,(HL)          ; LSB of line number
        INC     HL
        ld      D,(HL)          ; MSB of line number
        EX      DE,HL
        ld      (DATLIN),HL     ; Set line of current DATA item
        EX      DE,HL
FANDT:  CALL    GETCHR          ; Get next character
        CP      ZDATA           ; "DATA" token
        JP      NZ,FDTLP        ; No "DATA" - Keep looking
        JP      ANTVLU          ; Found - Convert input

NEXT:   ld      DE,0            ; In case no index given
NEXT1:  CALL    NZ,GETVAR       ; Get index address
        ld      (BRKLIN),HL     ; Save code string address
        CALL    BAKSTK          ; Look for "FOR" block
        JP      NZ,NFERR        ; No "FOR" - ?NF Error
        ld      SP,HL           ; Clear nested loops
        PUSH    DE              ; Save index address
        ld      A,(HL)          ; Get sign of STEP
        INC     HL
        PUSH    AF              ; Save sign of STEP
        PUSH    DE              ; Save index address
        CALL    PHLTFP          ; Move index value to FPREG
        EX      (SP),HL         ; Save address of TO value
        PUSH    HL              ; Save address of index
        CALL    ADDPHL          ; Add STEP to index value
        POP     HL              ; Restore address of index
        CALL    FPTHL           ; Move value to index variable
        POP     HL              ; Restore address of TO value
        CALL    LOADFP          ; Move TO value to BCDE
        PUSH    HL              ; Save address of line of FOR
        CALL    CMPNUM          ; Compare index with TO value
        POP     HL              ; Restore address of line num
        POP     BC              ; Address of sign of STEP
        SUB     B               ; Compare with expected sign
        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
        JP      Z,KILFOR        ; Loop finished - Terminate it
        EX      DE,HL           ; Loop statement line number
        ld      (LINEAT),HL     ; Set loop line number
        ld      L,C             ; Set code string to loop
        ld      H,B
        JP      PUTFID          ; Put back "FOR" and continue

KILFOR: ld      SP,HL           ; Remove "FOR" block
        ld      HL,(BRKLIN)     ; Code string after "NEXT"
        ld      A,(HL)          ; Get next byte in code string
        CP      ','             ; More NEXTs ?
        JP      NZ,RUNCNT       ; No - Do next statement
        CALL    GETCHR          ; Position to index name
        CALL    NEXT1           ; Re-enter NEXT routine
; < will not RETurn to here , Exit to RUNCNT or Loop >

GETNUM: CALL    EVAL            ; Get a numeric expression
TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
TSTSTR: SCF                     ; Set carry (string)
CHKTYP: ld      A,(TYPE)        ; Check types match
        ADC     A,A             ; Expected + actual
        OR      A               ; Clear carry , set parity
        RET     PE              ; Even parity - Types match
        JP      TMERR           ; Different types - Error

OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
        .BYTE   "("
EVAL:   DEC     HL              ; Evaluate expression & save
        ld      D,0             ; Precedence value
EVAL1:  PUSH    DE              ; Save precedence
        ld      C,1
        CALL    CHKSTK          ; Check for 1 level of stack
        CALL    OPRND           ; Get next expression value
EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
        POP     BC              ; Precedence value and operator
        ld      A,B             ; Get precedence value
        CP      78H             ; "AND" or "OR" ?
        CALL    NC,TSTNUM       ; No - Make sure it's a number
        ld      A,(HL)          ; Get next operator / function
        ld      D,0             ; Clear Last relation
RLTLP:  SUB     ZGTR            ; ">" Token
        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
        CP      ZLTH+1-ZGTR     ; < = >
        JP      NC,FOPRND       ; Function - Call it
        CP      ZEQUAL-ZGTR     ; "="
        RLA                     ; <- Test for legal
        XOR     D               ; <- combinations of < = >
        CP      D               ; <- by combining last token
        ld      D,A             ; <- with current one
        JP      C,SNERR         ; Error if "<<' '==" or ">>"
        ld      (CUROPR),HL     ; Save address of current token
        CALL    GETCHR          ; Get next character
        JP      RLTLP           ; Treat the two as one

FOPRND: ld      A,D             ; < = > found ?
        OR      A
        JP      NZ,TSTRED       ; Yes - Test for reduction
        ld      A,(HL)          ; Get operator token
        ld      (CUROPR),HL     ; Save operator address
        SUB     ZPLUS           ; Operator or function?
        RET     C               ; Neither - Exit
        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
        RET     NC              ; No - Exit
        ld      E,A             ; Coded operator
        ld      A,(TYPE)        ; Get data type
        DEC     A               ; FF = numeric , 00 = string
        OR      E               ; Combine with coded operator
        ld      A,E             ; Get coded operator
        JP      Z,CONCAT        ; String concatenation
        RLCA                    ; Times 2
        ADD     A,E             ; Times 3
        ld      E,A             ; To DE (D is 0)
        ld      HL,PRITAB       ; Precedence table
        ADD     HL,DE           ; To the operator concerned
        ld      A,B             ; Last operator precedence
        ld      D,(HL)          ; Get evaluation precedence
        CP      D               ; Compare with eval precedence
        RET     NC              ; Exit if higher precedence
        INC     HL              ; Point to routine address
        CALL    TSTNUM          ; Make sure it's a number

STKTHS: PUSH    BC              ; Save last precedence & token
        ld      BC,EVAL3        ; Where to go on prec' break
        PUSH    BC              ; Save on stack for return
        ld      B,E             ; Save operator
        ld      C,D             ; Save precedence
        CALL    STAKFP          ; Move value to stack
        ld      E,B             ; Restore operator
        ld      D,C             ; Restore precedence
        ld      C,(HL)          ; Get LSB of routine address
        INC     HL
        ld      B,(HL)          ; Get MSB of routine address
        INC     HL
        PUSH    BC              ; Save routine address
        ld      HL,(CUROPR)     ; Address of current operator
        JP      EVAL1           ; Loop until prec' break

OPRND:  XOR     A               ; Get operand routine
        ld      (TYPE),A        ; Set numeric expected
        CALL    GETCHR          ; Get next character
        ld      E,MO            ; ?MO Error
        JP      Z,ERROR         ; No operand - Error
        JP      C,ASCTFP        ; Number - Get value
        CALL    CHKLTR          ; See if a letter
        JP      NC,CONVAR       ; Letter - Find variable
        CP	'&'		; &H = HEX, &B = BINARY
        JR	NZ, NOTAMP
        CALL    GETCHR          ; Get next character
        CP      'H'             ; Hex number indicated? [function added]
        JP      Z,HEXTFP        ; Convert Hex to FPREG
        CP      'B'             ; Binary number indicated? [function added]
        JP      Z,BINTFP        ; Convert Bin to FPREG
        ld      E,SN            ; If neither then a ?SN Error
        JP      Z,ERROR         ; 
NOTAMP: CP      ZPLUS           ; '+' Token ?
        JP      Z,OPRND         ; Yes - Look for operand
        CP      '.'             ; '.' ?
        JP      Z,ASCTFP        ; Yes - Create FP number
        CP      ZMINUS          ; '-' Token ?
        JP      Z,MINUS         ; Yes - Do minus
        CP      022h            ; Literal string ?
        JP      Z,QTSTR         ; Get string terminated by '"'
        CP      ZNOT            ; "NOT" Token ?
        JP      Z,EVNOT         ; Yes - Eval NOT expression
        CP      ZFN             ; "FN" Token ?
        JP      Z,DOFN          ; Yes - Do FN routine
        SUB     ZSGN            ; Is it a function?
        JP      NC,FNOFST       ; Yes - Evaluate function
EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE   ")"
        RET

MINUS:  ld      D,7DH           ; '-' precedence
        CALL    EVAL1           ; Evaluate until prec' break
        ld      HL,(NXTOPR)     ; Get next operator address
        PUSH    HL              ; Save next operator address
        CALL    INVSGN          ; Negate value
RETNUM: CALL    TSTNUM          ; Make sure it's a number
        POP     HL              ; Restore next operator address
        RET

CONVAR: CALL    GETVAR          ; Get variable address to DE
FRMEVL: PUSH    HL              ; Save code string address
        EX      DE,HL           ; Variable address to HL
        ld      (FPREG),HL      ; Save address of variable
        ld      A,(TYPE)        ; Get type
        OR      A               ; Numeric?
        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
        POP     HL              ; Restore code string address
        RET

FNOFST: ld      B,0             ; Get address of function
        RLCA                    ; Double function offset
        ld      C,A             ; BC = Offset in function table
        PUSH    BC              ; Save adjusted token value
        CALL    GETCHR          ; Get next character
        ld      A,C             ; Get adjusted token value
        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
        JP      C,FNVAL         ; No - Do function
        CALL    OPNPAR          ; Evaluate expression  (X,...
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    TSTSTR          ; Make sure it's a string
        EX      DE,HL           ; Save code string address
        ld      HL,(FPREG)      ; Get address of string
        EX      (SP),HL         ; Save address of string
        PUSH    HL              ; Save adjusted token value
        EX      DE,HL           ; Restore code string address
        CALL    GETINT          ; Get integer 0-255
        EX      DE,HL           ; Save code string address
        EX      (SP),HL         ; Save integer,HL = adj' token
        JP      GOFUNC          ; Jump to string function

FNVAL:  CALL    EVLPAR          ; Evaluate expression
        EX      (SP),HL         ; HL = Adjusted token value
        ld      DE,RETNUM       ; Return number from function
        PUSH    DE              ; Save on stack
GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
        ADD     HL,BC           ; Point to right address
        ld      C,(HL)          ; Get LSB of address
        INC     HL              ;
        ld      H,(HL)          ; Get MSB of address
        ld      L,C             ; Address to HL
        JP      (HL)            ; Jump to function

SGNEXP: DEC     D               ; Dee to flag negative exponent
        CP      ZMINUS          ; '-' token ?
        RET     Z               ; Yes - Return
        CP      '-'             ; '-' ASCII ?
        RET     Z               ; Yes - Return
        INC     D               ; Inc to flag positive exponent
        CP      '+'             ; '+' ASCII ?
        RET     Z               ; Yes - Return
        CP      ZPLUS           ; '+' token ?
        RET     Z               ; Yes - Return
        DEC     HL              ; DEC 'cos GETCHR INCs
        RET                     ; Return "NZ"

POR:    .BYTE      0F6H            ; Flag "OR"
PAND:   XOR     A               ; Flag "AND"
        PUSH    AF              ; Save "AND" / "OR" flag
        CALL    TSTNUM          ; Make sure it's a number
        CALL    DEINT           ; Get integer -32768 to 32767
        POP     AF              ; Restore "AND" / "OR" flag
        EX      DE,HL           ; <- Get last
        POP     BC              ; <-  value
        EX      (SP),HL         ; <-  from
        EX      DE,HL           ; <-  stack
        CALL    FPBCDE          ; Move last value to FPREG
        PUSH    AF              ; Save "AND" / "OR" flag
        CALL    DEINT           ; Get integer -32768 to 32767
        POP     AF              ; Restore "AND" / "OR" flag
        POP     BC              ; Get value
        ld      A,C             ; Get LSB
        ld      HL,ACPASS       ; Address of save AC as current
        JP      NZ,POR1         ; Jump if OR
        AND     E               ; "AND" LSBs
        ld      C,A             ; Save LSB
        ld      A,B             ; Get MBS
        AND     D               ; "AND" MSBs
        JP      (HL)            ; Save AC as current (ACPASS)

POR1:   OR      E               ; "OR" LSBs
        ld      C,A             ; Save LSB
        ld      A,B             ; Get MSB
        OR      D               ; "OR" MSBs
        JP      (HL)            ; Save AC as current (ACPASS)

TSTRED: ld      HL,CMPLOG       ; Logical compare routine
        ld      A,(TYPE)        ; Get data type
        RRA                     ; Carry set = string
        ld      A,D             ; Get last precedence value
        RLA                     ; Times 2 plus carry
        ld      E,A             ; To E
        ld      D,64H           ; Relational precedence
        ld      A,B             ; Get current precedence
        CP      D               ; Compare with last
        RET     NC              ; Eval if last was rel' or log'
        JP      STKTHS          ; Stack this one and get next

CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
CMPLG1: ld      A,C             ; Get data type
        OR      A
        RRA
        POP     BC              ; Get last expression to BCDE
        POP     DE
        PUSH    AF              ; Save status
        CALL    CHKTYP          ; Check that types match
        ld      HL,CMPRES       ; Result to comparison
        PUSH    HL              ; Save for RETurn
        JP      Z,CMPNUM        ; Compare values if numeric
        XOR     A               ; Compare two strings
        ld      (TYPE),A        ; Set type to numeric
        PUSH    DE              ; Save string name
        CALL    GSTRCU          ; Get current string
        ld      A,(HL)          ; Get length of string
        INC     HL
        INC     HL
        ld      C,(HL)          ; Get LSB of address
        INC     HL
        ld      B,(HL)          ; Get MSB of address
        POP     DE              ; Restore string name
        PUSH    BC              ; Save address of string
        PUSH    AF              ; Save length of string
        CALL    GSTRDE          ; Get second string
        CALL    LOADFP          ; Get address of second string
        POP     AF              ; Restore length of string 1
        ld      D,A             ; Length to D
        POP     HL              ; Restore address of string 1
CMPSTR: ld      A,E             ; Bytes of string 2 to do
        OR      D               ; Bytes of string 1 to do
        RET     Z               ; Exit if all bytes compared
        ld      A,D             ; Get bytes of string 1 to do
        SUB     1
        RET     C               ; Exit if end of string 1
        XOR     A
        CP      E               ; Bytes of string 2 to do
        INC     A
        RET     NC              ; Exit if end of string 2
        DEC     D               ; Count bytes in string 1
        DEC     E               ; Count bytes in string 2
        ld      A,(BC)          ; Byte in string 2
        CP      (HL)            ; Compare to byte in string 1
        INC     HL              ; Move up string 1
        INC     BC              ; Move up string 2
        JP      Z,CMPSTR        ; Same - Try next bytes
        CCF                     ; Flag difference (">" or "<")
        JP      FLGDIF          ; "<" gives -1 , ">" gives +1

CMPRES: INC     A               ; Increment current value
        ADC     A,A             ; Double plus carry
        POP     BC              ; Get other value
        AND     B               ; Combine them
        ADD     A,-1            ; Carry set if different
        SBC     A,A             ; 00 - Equal , FF - Different
        JP      FLGREL          ; Set current value & continue

EVNOT:  ld      D,5AH           ; Precedence value for "NOT"
        CALL    EVAL1           ; Eval until precedence break
        CALL    TSTNUM          ; Make sure it's a number
        CALL    DEINT           ; Get integer -32768 - 32767
        ld      A,E             ; Get LSB
        CPL                     ; Invert LSB
        ld      C,A             ; Save "NOT" of LSB
        ld      A,D             ; Get MSB
        CPL                     ; Invert MSB
        CALL    ACPASS          ; Save AC as current
        POP     BC              ; Clean up stack
        JP      EVAL3           ; Continue evaluation

DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        RET     Z               ; End of DIM statement
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
        PUSH    BC              ; Save on stack
        .BYTE      0F6H            ; Flag "Create" variable
GETVAR: XOR     A               ; Find variable address,to DE
        ld      (LCRFLG),A      ; Set locate / create flag
        ld      B,(HL)          ; Get First byte of name
GTFNAM: CALL    CHKLTR          ; See if a letter
        JP      C,SNERR         ; ?SN Error if not a letter
        XOR     A
        ld      C,A             ; Clear second byte of name
        ld      (TYPE),A        ; Set type to numeric
        CALL    GETCHR          ; Get next character
        JP      C,SVNAM2        ; Numeric - Save in name
        CALL    CHKLTR          ; See if a letter
        JP      C,CHARTY        ; Not a letter - Check type
SVNAM2: ld      C,A             ; Save second byte of name
ENDNAM: CALL    GETCHR          ; Get next character
        JP      C,ENDNAM        ; Numeric - Get another
        CALL    CHKLTR          ; See if a letter
        JP      NC,ENDNAM       ; Letter - Get another
CHARTY: SUB     '$'             ; String variable?
        JP      NZ,NOTSTR       ; No - Numeric variable
        INC     A               ; A = 1 (string type)
        ld      (TYPE),A        ; Set type to string
        RRCA                    ; A = 80H , Flag for string
        ADD     A,C             ; 2nd byte of name has bit 7 on
        ld      C,A             ; Resave second byte on name
        CALL    GETCHR          ; Get next character
NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
        DEC     A
        JP      Z,ARLDSV        ; Yes - Get array name
        JP      P,NSCFOR        ; No array with "FOR" or "FN"
        ld      A,(HL)          ; Get byte again
        SUB     '('             ; Subscripted variable?
        JP      Z,SBSCPT        ; Yes - Sort out subscript

NSCFOR: XOR     A               ; Simple variable
        ld      (FORFLG),A      ; Clear "FOR" flag
        PUSH    HL              ; Save code string address
        ld      D,B             ; DE = Variable name to find
        ld      E,C
        ld      HL,(FNRGNM)     ; FN argument name
        CALL    CPDEHL          ; Is it the FN argument?
        ld      DE,FNARG        ; Point to argument value
        JP      Z,POPHRT        ; Yes - Return FN argument value
        ld      HL,(VAREND)     ; End of variables
        EX      DE,HL           ; Address of end of search
        ld      HL,(PROGND)     ; Start of variables address
FNDVAR: CALL    CPDEHL          ; End of variable list table?
        JP      Z,CFEVAL        ; Yes - Called from EVAL?
        ld      A,C             ; Get second byte of name
        SUB     (HL)            ; Compare with name in list
        INC     HL              ; Move on to first byte
        JP      NZ,FNTHR        ; Different - Find another
        ld      A,B             ; Get first byte of name
        SUB     (HL)            ; Compare with name in list
FNTHR:  INC     HL              ; Move on to LSB of value
        JP      Z,RETADR        ; Found - Return address
        INC     HL              ; <- Skip
        INC     HL              ; <- over
        INC     HL              ; <- F.P.
        INC     HL              ; <- value
        JP      FNDVAR          ; Keep looking

CFEVAL: POP     HL              ; Restore code string address
        EX      (SP),HL         ; Get return address
        PUSH    DE              ; Save address of variable
        ld      DE,FRMEVL       ; Return address in EVAL
        CALL    CPDEHL          ; Called from EVAL ?
        POP     DE              ; Restore address of variable
        JP      Z,RETNUL        ; Yes - Return null variable
        EX      (SP),HL         ; Put back return
        PUSH    HL              ; Save code string address
        PUSH    BC              ; Save variable name
        ld      BC,6            ; 2 byte name plus 4 byte data
        ld      HL,(ARREND)     ; End of arrays
        PUSH    HL              ; Save end of arrays
        ADD     HL,BC           ; Move up 6 bytes
        POP     BC              ; Source address in BC
        PUSH    HL              ; Save new end address
        CALL    MOVUP           ; Move arrays up
        POP     HL              ; Restore new end address
        ld      (ARREND),HL     ; Set new end address
        ld      H,B             ; End of variables to HL
        ld      L,C
        ld      (VAREND),HL     ; Set new end address

ZEROLP: DEC     HL              ; Back through to zero variable
        ld      (HL),0          ; Zero byte in variable
        CALL    CPDEHL          ; Done them all?
        JP      NZ,ZEROLP       ; No - Keep on going
        POP     DE              ; Get variable name
        ld      (HL),E          ; Store second character
        INC     HL
        ld      (HL),D          ; Store first character
        INC     HL
RETADR: EX      DE,HL           ; Address of variable in DE
        POP     HL              ; Restore code string address
        RET

RETNUL: ld      (FPEXP),A       ; Set result to zero
        ld      HL,ZERBYT       ; Also set a null string
        ld      (FPREG),HL      ; Save for EVAL
        POP     HL              ; Restore code string address
        RET

SBSCPT: PUSH    HL              ; Save code string address
        ld      HL,(LCRFLG)     ; Locate/Create and Type
        EX      (SP),HL         ; Save and get code string
        ld      D,A             ; Zero number of dimensions
SCPTLP: PUSH    DE              ; Save number of dimensions
        PUSH    BC              ; Save array name
        CALL    FPSINT          ; Get subscript (0-32767)
        POP     BC              ; Restore array name
        POP     AF              ; Get number of dimensions
        EX      DE,HL
        EX      (SP),HL         ; Save subscript value
        PUSH    HL              ; Save LCRFLG and TYPE
        EX      DE,HL
        INC     A               ; Count dimensions
        ld      D,A             ; Save in D
        ld      A,(HL)          ; Get next byte in code string
        CP      ','             ; Comma (more to come)?
        JP      Z,SCPTLP        ; Yes - More subscripts
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        ld      (NXTOPR),HL     ; Save code string address
        POP     HL              ; Get LCRFLG and TYPE
        ld      (LCRFLG),HL     ; Restore Locate/create & type
        ld      E,0             ; Flag not CSAVE* or CLOAD*
        PUSH    DE              ; Save number of dimensions (D)
        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'

ARLDSV: PUSH    HL              ; Save code string address
        PUSH    AF              ; A = 00 , Flags set = Z,N
        ld      HL,(VAREND)     ; Start of arrays
        .BYTE      3EH             ; Skip "ADD HL,DE"
FNDARY: ADD     HL,DE           ; Move to next array start
        EX      DE,HL
        ld      HL,(ARREND)     ; End of arrays
        EX      DE,HL           ; Current array pointer
        CALL    CPDEHL          ; End of arrays found?
        JP      Z,CREARY        ; Yes - Create array
        ld      A,(HL)          ; Get second byte of name
        CP      C               ; Compare with name given
        INC     HL              ; Move on
        JP      NZ,NXTARY       ; Different - Find next array
        ld      A,(HL)          ; Get first byte of name
        CP      B               ; Compare with name given
NXTARY: INC     HL              ; Move on
        ld      E,(HL)          ; Get LSB of next array address
        INC     HL
        ld      D,(HL)          ; Get MSB of next array address
        INC     HL
        JP      NZ,FNDARY       ; Not found - Keep looking
        ld      A,(LCRFLG)      ; Found Locate or Create it?
        OR      A
        JP      NZ,DDERR        ; Create - ?DD Error
        POP     AF              ; Locate - Get number of dim'ns
        ld      B,H             ; BC Points to array dim'ns
        ld      C,L
        JP      Z,POPHRT        ; Jump if array load/save
        SUB     (HL)            ; Same number of dimensions?
        JP      Z,FINDEL        ; Yes - Find element
BSERR:  ld      E,BS            ; ?BS Error
        JP      ERROR           ; Output error

CREARY: ld      DE,4            ; 4 Bytes per entry
        POP     AF              ; Array to save or 0 dim'ns?
        JP      Z,FCERR         ; Yes - ?FC Error
        ld      (HL),C          ; Save second byte of name
        INC     HL
        ld      (HL),B          ; Save first byte of name
        INC     HL
        ld      C,A             ; Number of dimensions to C
        CALL    CHKSTK          ; Check if enough memory
        INC     HL              ; Point to number of dimensions
        INC     HL
        ld      (CUROPR),HL     ; Save address of pointer
        ld      (HL),C          ; Set number of dimensions
        INC     HL
        ld      A,(LCRFLG)      ; Locate of Create?
        RLA                     ; Carry set = Create
        ld      A,C             ; Get number of dimensions
CRARLP: ld      BC,10+1         ; Default dimension size 10
        JP      NC,DEFSIZ       ; Locate - Set default size
        POP     BC              ; Get specified dimension size
        INC     BC              ; Include zero element
DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
        INC     HL
        ld      (HL),B          ; Save MSB of dimension size
        INC     HL
        PUSH    AF              ; Save num' of dim'ns an status
        PUSH    HL              ; Save address of dim'n size
        CALL    MLDEBC          ; Multiply DE by BC to find
        EX      DE,HL           ; amount of mem needed (to DE)
        POP     HL              ; Restore address of dimension
        POP     AF              ; Restore number of dimensions
        DEC     A               ; Count them
        JP      NZ,CRARLP       ; Do next dimension if more
        PUSH    AF              ; Save locate/create flag
        ld      B,D             ; MSB of memory needed
        ld      C,E             ; LSB of memory needed
        EX      DE,HL
        ADD     HL,DE           ; Add bytes to array start
        JP      C,OMERR         ; Too big - Error
        CALL    ENFMEM          ; See if enough memory
        ld      (ARREND),HL     ; Save new end of array

ZERARY: DEC     HL              ; Back through array data
        ld      (HL),0          ; Set array element to zero
        CALL    CPDEHL          ; All elements zeroed?
        JP      NZ,ZERARY       ; No - Keep on going
        INC     BC              ; Number of bytes + 1
        ld      D,A             ; A=0
        ld      HL,(CUROPR)     ; Get address of array
        ld      E,(HL)          ; Number of dimensions
        EX      DE,HL           ; To HL
        ADD     HL,HL           ; Two bytes per dimension size
        ADD     HL,BC           ; Add number of bytes
        EX      DE,HL           ; Bytes needed to DE
        DEC     HL
        DEC     HL
        ld      (HL),E          ; Save LSB of bytes needed
        INC     HL
        ld      (HL),D          ; Save MSB of bytes needed
        INC     HL
        POP     AF              ; Locate / Create?
        JP      C,ENDDIM        ; A is 0 , End if create
FINDEL: ld      B,A             ; Find array element
        ld      C,A
        ld      A,(HL)          ; Number of dimensions
        INC     HL
        .BYTE      16H             ; Skip "POP HL"
FNDELP: POP     HL              ; Address of next dim' size
        ld      E,(HL)          ; Get LSB of dim'n size
        INC     HL
        ld      D,(HL)          ; Get MSB of dim'n size
        INC     HL
        EX      (SP),HL         ; Save address - Get index
        PUSH    AF              ; Save number of dim'ns
        CALL    CPDEHL          ; Dimension too large?
        JP      NC,BSERR        ; Yes - ?BS Error
        PUSH    HL              ; Save index
        CALL    MLDEBC          ; Multiply previous by size
        POP     DE              ; Index supplied to DE
        ADD     HL,DE           ; Add index to pointer
        POP     AF              ; Number of dimensions
        DEC     A               ; Count them
        ld      B,H             ; MSB of pointer
        ld      C,L             ; LSB of pointer
        JP      NZ,FNDELP       ; More - Keep going
        ADD     HL,HL           ; 4 Bytes per element
        ADD     HL,HL
        POP     BC              ; Start of array
        ADD     HL,BC           ; Point to element
        EX      DE,HL           ; Address of element to DE
ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
        RET

FRE:    ld      HL,(ARREND)     ; Start of free memory
        EX      DE,HL           ; To DE
        ld      HL,0            ; End of free memory
        ADD     HL,SP           ; Current stack value
        ld      A,(TYPE)        ; Dummy argument type
        OR      A
        JP      Z,FRENUM        ; Numeric - Free variable space
        CALL    GSTRCU          ; Current string to pool
        CALL    GARBGE          ; Garbage collection
        ld      HL,(STRSPC)     ; Bottom of string space in use
        EX      DE,HL           ; To DE
        ld      HL,(STRBOT)     ; Bottom of string space
FRENUM: ld      A,L             ; Get LSB of end
        SUB     E               ; Subtract LSB of beginning
        ld      C,A             ; Save difference if C
        ld      A,H             ; Get MSB of end
        SBC     A,D             ; Subtract MSB of beginning
ACPASS: ld      B,C             ; Return integer AC
ABPASS: ld      D,B             ; Return integer AB
        ld      E,0
        ld      HL,TYPE         ; Point to type
        ld      (HL),E          ; Set type to numeric
        ld      B,80H+16        ; 16 bit integer
        JP      RETINT          ; Return the integr

POS:    ld      A,(CURPOS)      ; Get cursor position
PASSA:  ld      B,A             ; Put A into AB
        XOR     A               ; Zero A
        JP      ABPASS          ; Return integer AB

DEF:    CALL    CHEKFN          ; Get "FN" and name
        CALL    IDTEST          ; Test for illegal direct
        ld      BC,DATA         ; To get next statement
        PUSH    BC              ; Save address for RETurn
        PUSH    DE              ; Save address of function ptr
        CALL    CHKSYN          ; Make sure "(" follows
        .BYTE      "("
        CALL    GETVAR          ; Get argument variable name
        PUSH    HL              ; Save code string address
        EX      DE,HL           ; Argument address to HL
        DEC     HL
        ld      D,(HL)          ; Get first byte of arg name
        DEC     HL
        ld      E,(HL)          ; Get second byte of arg name
        POP     HL              ; Restore code string address
        CALL    TSTNUM          ; Make sure numeric argument
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        CALL    CHKSYN          ; Make sure "=" follows
        .BYTE      ZEQUAL          ; "=" token
        ld      B,H             ; Code string address to BC
        ld      C,L
        EX      (SP),HL         ; Save code str , Get FN ptr
        ld      (HL),C          ; Save LSB of FN code string
        INC     HL
        ld      (HL),B          ; Save MSB of FN code string
        JP      SVSTAD          ; Save address and do function

DOFN:   CALL    CHEKFN          ; Make sure FN follows
        PUSH    DE              ; Save function pointer address
        CALL    EVLPAR          ; Evaluate expression in "()"
        CALL    TSTNUM          ; Make sure numeric result
        EX      (SP),HL         ; Save code str , Get FN ptr
        ld      E,(HL)          ; Get LSB of FN code string
        INC     HL
        ld      D,(HL)          ; Get MSB of FN code string
        INC     HL
        ld      A,D             ; And function DEFined?
        OR      E
        JP      Z,UFERR         ; No - ?UF Error
        ld      A,(HL)          ; Get LSB of argument address
        INC     HL
        ld      H,(HL)          ; Get MSB of argument address
        ld      L,A             ; HL = Arg variable address
        PUSH    HL              ; Save it
        ld      HL,(FNRGNM)     ; Get old argument name
        EX      (SP),HL ;       ; Save old , Get new
        ld      (FNRGNM),HL     ; Set new argument name
        ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
        PUSH    HL              ; Save it
        ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
        PUSH    HL              ; Save it
        ld      HL,FNARG        ; HL = Value of argument
        PUSH    DE              ; Save FN code string address
        CALL    FPTHL           ; Move FPREG to argument
        POP     HL              ; Get FN code string address
        CALL    GETNUM          ; Get value from function
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      NZ,SNERR        ; Bad character in FN - Error
        POP     HL              ; Get MSB,EXP of old arg
        ld      (FNARG),HL      ; Restore it
        POP     HL              ; Get LSB,NLSB of old arg
        ld      (FNARG+2),HL    ; Restore it
        POP     HL              ; Get name of old arg
        ld      (FNRGNM),HL     ; Restore it
        POP     HL              ; Restore code string address
        RET

IDTEST: PUSH    HL              ; Save code string address
        ld      HL,(LINEAT)     ; Get current line number
        INC     HL              ; -1 means direct statement
        ld      A,H
        OR      L
        POP     HL              ; Restore code string address
        RET     NZ              ; Return if in program
        ld      E,ID            ; ?ID Error
        JP      ERROR

CHEKFN: CALL    CHKSYN          ; Make sure FN follows
        .BYTE      ZFN             ; "FN" token
        ld      A,80H
        ld      (FORFLG),A      ; Flag FN name to find
        OR      (HL)            ; FN name has bit 7 set
        ld      B,A             ; in first byte of name
        CALL    GTFNAM          ; Get FN name
        JP      TSTNUM          ; Make sure numeric function

STR:    CALL    TSTNUM          ; Make sure it's a number
        CALL    NUMASC          ; Turn number into text
STR1:   CALL    CRTST           ; Create string entry for it
        CALL    GSTRCU          ; Current string to pool
        ld      BC,TOPOOL       ; Save in string pool
        PUSH    BC              ; Save address on stack

SAVSTR: ld      A,(HL)          ; Get string length
        INC     HL
        INC     HL
        PUSH    HL              ; Save pointer to string
        CALL    TESTR           ; See if enough string space
        POP     HL              ; Restore pointer to string
        ld      C,(HL)          ; Get LSB of address
        INC     HL
        ld      B,(HL)          ; Get MSB of address
        CALL    CRTMST          ; Create string entry
        PUSH    HL              ; Save pointer to MSB of addr
        ld      L,A             ; Length of string
        CALL    TOSTRA          ; Move to string area
        POP     DE              ; Restore pointer to MSB
        RET

MKTMST: CALL    TESTR           ; See if enough string space
CRTMST: ld      HL,TMPSTR       ; Temporary string
        PUSH    HL              ; Save it
        ld      (HL),A          ; Save length of string
        INC     HL
SVSTAD: INC     HL
        ld      (HL),E          ; Save LSB of address
        INC     HL
        ld      (HL),D          ; Save MSB of address
        POP     HL              ; Restore pointer
        RET

CRTST:  DEC     HL              ; DEC - INCed after
QTSTR:  ld      B,022h          ; Terminating quote
        ld      D,B             ; Quote to D
DTSTR:  PUSH    HL              ; Save start
        ld      C,-1            ; Set counter to -1
QTSTLP: INC     HL              ; Move on
        ld      A,(HL)          ; Get byte
        INC     C               ; Count bytes
        OR      A               ; End of line?
        JP      Z,CRTSTE        ; Yes - Create string entry
        CP      D               ; Terminator D found?
        JP      Z,CRTSTE        ; Yes - Create string entry
        CP      B               ; Terminator B found?
        JP      NZ,QTSTLP       ; No - Keep looking
CRTSTE: CP      022h             ; End with '"'?
        CALL    Z,GETCHR        ; Yes - Get next character
        EX      (SP),HL         ; Starting quote
        INC     HL              ; First byte of string
        EX      DE,HL           ; To DE
        ld      A,C             ; Get length
        CALL    CRTMST          ; Create string entry
TSTOPL: ld      DE,TMPSTR       ; Temporary string
        ld      HL,(TMSTPT)     ; Temporary string pool pointer
        ld      (FPREG),HL      ; Save address of string ptr
        ld      A,1
        ld      (TYPE),A        ; Set type to string
        CALL    DETHL4          ; Move string to pool
        CALL    CPDEHL          ; Out of string pool?
        ld      (TMSTPT),HL     ; Save new pointer
        POP     HL              ; Restore code string address
        ld      A,(HL)          ; Get next code byte
        RET     NZ              ; Return if pool OK
        ld      E,ST            ; ?ST Error
        JP      ERROR           ; String pool overflow

PRNUMS: INC     HL              ; Skip leading space
PRS:    CALL    CRTST           ; Create string entry for it
PRS1:   CALL    GSTRCU          ; Current string to pool
        CALL    LOADFP          ; Move string block to BCDE
        INC     E               ; Length + 1
PRSLP:  DEC     E               ; Count characters
        RET     Z               ; End of string
        ld      A,(BC)          ; Get byte to output
        CALL    OUTC            ; Output character in A
        CP      CR              ; Return?
        CALL    Z,DONULL        ; Yes - Do nulls
        INC     BC              ; Next byte in string
        JP      PRSLP           ; More characters to output

TESTR:  OR      A               ; Test if enough room
        .BYTE      0EH             ; No garbage collection done
GRBDON: POP     AF              ; Garbage collection done
        PUSH    AF              ; Save status
        ld      HL,(STRSPC)     ; Bottom of string space in use
        EX      DE,HL           ; To DE
        ld      HL,(STRBOT)     ; Bottom of string area
        CPL                     ; Negate length (Top down)
        ld      C,A             ; -Length to BC
        ld      B,-1            ; BC = -ve length of string
        ADD     HL,BC           ; Add to bottom of space in use
        INC     HL              ; Plus one for 2's complement
        CALL    CPDEHL          ; Below string RAM area?
        JP      C,TESTOS        ; Tidy up if not done else err
        ld      (STRBOT),HL     ; Save new bottom of area
        INC     HL              ; Point to first byte of string
        EX      DE,HL           ; Address to DE
POPAF:  POP     AF              ; Throw away status push
        RET

TESTOS: POP     AF              ; Garbage collect been done?
        ld      E,OS            ; ?OS Error
        JP      Z,ERROR         ; Yes - Not enough string apace
        CP      A               ; Flag garbage collect done
        PUSH    AF              ; Save status
        ld      BC,GRBDON       ; Garbage collection done
        PUSH    BC              ; Save for RETurn
GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
GARBLP: ld      (STRBOT),HL     ; Reset string pointer
        ld      HL,0
        PUSH    HL              ; Flag no string found
        ld      HL,(STRSPC)     ; Get bottom of string space
        PUSH    HL              ; Save bottom of string space
        ld      HL,TMSTPL       ; Temporary string pool
GRBLP:  EX      DE,HL
        ld      HL,(TMSTPT)     ; Temporary string pool pointer
        EX      DE,HL
        CALL    CPDEHL          ; Temporary string pool done?
        ld      BC,GRBLP        ; Loop until string pool done
        JP      NZ,STPOOL       ; No - See if in string area
        ld      HL,(PROGND)     ; Start of simple variables
SMPVAR: EX      DE,HL
        ld      HL,(VAREND)     ; End of simple variables
        EX      DE,HL
        CALL    CPDEHL          ; All simple strings done?
        JP      Z,ARRLP         ; Yes - Do string arrays
        ld      A,(HL)          ; Get type of variable
        INC     HL
        INC     HL
        OR      A               ; "S" flag set if string
        CALL    STRADD          ; See if string in string area
        JP      SMPVAR          ; Loop until simple ones done

GNXARY: POP     BC              ; Scrap address of this array
ARRLP:  EX      DE,HL
        ld      HL,(ARREND)     ; End of string arrays
        EX      DE,HL
        CALL    CPDEHL          ; All string arrays done?
        JP      Z,SCNEND        ; Yes - Move string if found
        CALL    LOADFP          ; Get array name to BCDE
        ld      A,E             ; Get type of array     
        PUSH    HL              ; Save address of num of dim'ns
        ADD     HL,BC           ; Start of next array
        OR      A               ; Test type of array
        JP      P,GNXARY        ; Numeric array - Ignore it
        ld      (CUROPR),HL     ; Save address of next array
        POP     HL              ; Get address of num of dim'ns
        ld      C,(HL)          ; BC = Number of dimensions
        ld      B,0
        ADD     HL,BC           ; Two bytes per dimension size
        ADD     HL,BC
        INC     HL              ; Plus one for number of dim'ns
GRBARY: EX      DE,HL
        ld      HL,(CUROPR)     ; Get address of next array
        EX      DE,HL
        CALL    CPDEHL          ; Is this array finished?
        JP      Z,ARRLP         ; Yes - Get next one
        ld      BC,GRBARY       ; Loop until array all done
STPOOL: PUSH    BC              ; Save return address
        OR      80H             ; Flag string type
STRADD: ld      A,(HL)          ; Get string length
        INC     HL
        INC     HL
        ld      E,(HL)          ; Get LSB of string address
        INC     HL
        ld      D,(HL)          ; Get MSB of string address
        INC     HL
        RET     P               ; Not a string - Return
        OR      A               ; Set flags on string length
        RET     Z               ; Null string - Return
        ld      B,H             ; Save variable pointer
        ld      C,L
        ld      HL,(STRBOT)     ; Bottom of new area
        CALL    CPDEHL          ; String been done?
        ld      H,B             ; Restore variable pointer
        ld      L,C
        RET     C               ; String done - Ignore
        POP     HL              ; Return address
        EX      (SP),HL         ; Lowest available string area
        CALL    CPDEHL          ; String within string area?
        EX      (SP),HL         ; Lowest available string area
        PUSH    HL              ; Re-save return address
        ld      H,B             ; Restore variable pointer
        ld      L,C
        RET     NC              ; Outside string area - Ignore
        POP     BC              ; Get return , Throw 2 away
        POP     AF              ; 
        POP     AF              ; 
        PUSH    HL              ; Save variable pointer
        PUSH    DE              ; Save address of current
        PUSH    BC              ; Put back return address
        RET                     ; Go to it

SCNEND: POP     DE              ; Addresses of strings
        POP     HL              ; 
        ld      A,L             ; HL = 0 if no more to do
        OR      H
        RET     Z               ; No more to do - Return
        DEC     HL
        ld      B,(HL)          ; MSB of address of string
        DEC     HL
        ld      C,(HL)          ; LSB of address of string
        PUSH    HL              ; Save variable address
        DEC     HL
        DEC     HL
        ld      L,(HL)          ; HL = Length of string
        ld      H,0
        ADD     HL,BC           ; Address of end of string+1
        ld      D,B             ; String address to DE
        ld      E,C
        DEC     HL              ; Last byte in string
        ld      B,H             ; Address to BC
        ld      C,L
        ld      HL,(STRBOT)     ; Current bottom of string area
        CALL    MOVSTR          ; Move string to new address
        POP     HL              ; Restore variable address
        ld      (HL),C          ; Save new LSB of address
        INC     HL
        ld      (HL),B          ; Save new MSB of address
        ld      L,C             ; Next string area+1 to HL
        ld      H,B
        DEC     HL              ; Next string area address
        JP      GARBLP          ; Look for more strings

CONCAT: PUSH    BC              ; Save prec' opr & code string
        PUSH    HL              ; 
        ld      HL,(FPREG)      ; Get first string
        EX      (SP),HL         ; Save first string
        CALL    OPRND           ; Get second string
        EX      (SP),HL         ; Restore first string
        CALL    TSTSTR          ; Make sure it's a string
        ld      A,(HL)          ; Get length of second string
        PUSH    HL              ; Save first string
        ld      HL,(FPREG)      ; Get second string
        PUSH    HL              ; Save second string
        ADD     A,(HL)          ; Add length of second string
        ld      E,LS            ; ?LS Error
        JP      C,ERROR         ; String too long - Error
        CALL    MKTMST          ; Make temporary string
        POP     DE              ; Get second string to DE
        CALL    GSTRDE          ; Move to string pool if needed
        EX      (SP),HL         ; Get first string
        CALL    GSTRHL          ; Move to string pool if needed
        PUSH    HL              ; Save first string
        ld      HL,(TMPSTR+2)   ; Temporary string address
        EX      DE,HL           ; To DE
        CALL    SSTSA           ; First string to string area
        CALL    SSTSA           ; Second string to string area
        ld      HL,EVAL2        ; Return to evaluation loop
        EX      (SP),HL         ; Save return,get code string
        PUSH    HL              ; Save code string address
        JP      TSTOPL          ; To temporary string to pool

SSTSA:  POP     HL              ; Return address
        EX      (SP),HL         ; Get string block,save return
        ld      A,(HL)          ; Get length of string
        INC     HL
        INC     HL
        ld      C,(HL)          ; Get LSB of string address
        INC     HL
        ld      B,(HL)          ; Get MSB of string address
        ld      L,A             ; Length to L
TOSTRA: INC     L               ; INC - DECed after
TSALP:  DEC     L               ; Count bytes moved
        RET     Z               ; End of string - Return
        ld      A,(BC)          ; Get source
        ld      (DE),A          ; Save destination
        INC     BC              ; Next source
        INC     DE              ; Next destination
        JP      TSALP           ; Loop until string moved

GETSTR: CALL    TSTSTR          ; Make sure it's a string
GSTRCU: ld      HL,(FPREG)      ; Get current string
GSTRHL: EX      DE,HL           ; Save DE
GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
        EX      DE,HL           ; Restore DE
        RET     NZ              ; No - Return
        PUSH    DE              ; Save string
        ld      D,B             ; String block address to DE
        ld      E,C
        DEC     DE              ; Point to length
        ld      C,(HL)          ; Get string length
        ld      HL,(STRBOT)     ; Current bottom of string area
        CALL    CPDEHL          ; Last one in string area?
        JP      NZ,POPHL        ; No - Return
        ld      B,A             ; Clear B (A=0)
        ADD     HL,BC           ; Remove string from str' area
        ld      (STRBOT),HL     ; Save new bottom of str' area
POPHL:  POP     HL              ; Restore string
        RET

BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
        DEC     HL              ; Back
        ld      B,(HL)          ; Get MSB of address
        DEC     HL              ; Back
        ld      C,(HL)          ; Get LSB of address
        DEC     HL              ; Back
        DEC     HL              ; Back
        CALL    CPDEHL          ; String last in string pool?
        RET     NZ              ; Yes - Leave it
        ld      (TMSTPT),HL     ; Save new string pool top
        RET

LEN:    ld      BC,PASSA        ; To return integer A
        PUSH    BC              ; Save address
GETLEN: CALL    GETSTR          ; Get string and its length
        XOR     A
        ld      D,A             ; Clear D
        ld      (TYPE),A        ; Set type to numeric
        ld      A,(HL)          ; Get length of string
        OR      A               ; Set status flags
        RET

ASC:    ld      BC,PASSA        ; To return integer A
        PUSH    BC              ; Save address
GTFLNM: CALL    GETLEN          ; Get length of string
        JP      Z,FCERR         ; Null string - Error
        INC     HL
        INC     HL
        ld      E,(HL)          ; Get LSB of address
        INC     HL
        ld      D,(HL)          ; Get MSB of address
        ld      A,(DE)          ; Get first byte of string
        RET

CHR:    ld      A,1             ; One character string
        CALL    MKTMST          ; Make a temporary string
        CALL    MAKINT          ; Make it integer A
        ld      HL,(TMPSTR+2)   ; Get address of string
        ld      (HL),E          ; Save character
TOPOOL: POP     BC              ; Clean up stack
        JP      TSTOPL          ; Temporary string to pool

LEFT:   CALL    LFRGNM          ; Get number and ending ")"
        XOR     A               ; Start at first byte in string
RIGHT1: EX      (SP),HL         ; Save code string,Get string
        ld      C,A             ; Starting position in string
MID1:   PUSH    HL              ; Save string block address
        ld      A,(HL)          ; Get length of string
        CP      B               ; Compare with number given
        JP      C,ALLFOL        ; All following bytes required
        ld      A,B             ; Get new length
        .BYTE      11H             ; Skip "ld C,0"
ALLFOL: ld      C,0             ; First byte of string
        PUSH    BC              ; Save position in string
        CALL    TESTR           ; See if enough string space
        POP     BC              ; Get position in string
        POP     HL              ; Restore string block address
        PUSH    HL              ; And re-save it
        INC     HL
        INC     HL
        ld      B,(HL)          ; Get LSB of address
        INC     HL
        ld      H,(HL)          ; Get MSB of address
        ld      L,B             ; HL = address of string
        ld      B,0             ; BC = starting address
        ADD     HL,BC           ; Point to that byte
        ld      B,H             ; BC = source string
        ld      C,L
        CALL    CRTMST          ; Create a string entry
        ld      L,A             ; Length of new string
        CALL    TOSTRA          ; Move string to string area
        POP     DE              ; Clear stack
        CALL    GSTRDE          ; Move to string pool if needed
        JP      TSTOPL          ; Temporary string to pool

RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
        POP     DE              ; Get string length
        PUSH    DE              ; And re-save
        ld      A,(DE)          ; Get length
        SUB     B               ; Move back N bytes
        JP      RIGHT1          ; Go and get sub-string

MID:    EX      DE,HL           ; Get code string address
        ld      A,(HL)          ; Get next byte ',' or ")"
        CALL    MIDNUM          ; Get number supplied
        INC     B               ; Is it character zero?
        DEC     B
        JP      Z,FCERR         ; Yes - Error
        PUSH    BC              ; Save starting position
        ld      E,255           ; All of string
        CP      ')'             ; Any length given?
        JP      Z,RSTSTR        ; No - Rest of string
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255
RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        POP     AF              ; Restore starting position
        EX      (SP),HL         ; Get string,8ave code string
        ld      BC,MID1         ; Continuation of MID$ routine
        PUSH    BC              ; Save for return
        DEC     A               ; Starting position-1
        CP      (HL)            ; Compare with length
        ld      B,0             ; Zero bytes length
        RET     NC              ; Null string if start past end
        ld      C,A             ; Save starting position-1
        ld      A,(HL)          ; Get length of string
        SUB     C               ; Subtract start
        CP      E               ; Enough string for it?
        ld      B,A             ; Save maximum length available
        RET     C               ; Truncate string if needed
        ld      B,E             ; Set specified length
        RET                     ; Go and create string

VAL:    CALL    GETLEN          ; Get length of string
        JP      Z,RESZER        ; Result zero
        ld      E,A             ; Save length
        INC     HL
        INC     HL
        ld      A,(HL)          ; Get LSB of address
        INC     HL
        ld      H,(HL)          ; Get MSB of address
        ld      L,A             ; HL = String address
        PUSH    HL              ; Save string address
        ADD     HL,DE
        ld      B,(HL)          ; Get end of string+1 byte
        ld      (HL),D          ; Zero it to terminate
        EX      (SP),HL         ; Save string end,get start
        PUSH    BC              ; Save end+1 byte
        ld      A,(HL)          ; Get starting byte
    CP	'$'		; Hex number indicated? [function added]
    JP	NZ,VAL1
    CALL	HEXTFP		; Convert Hex to FPREG
    JR	VAL3
VAL1:	CP	'%'		; Binary number indicated? [function added]
    JP	NZ,VAL2
    CALL	BINTFP		; Convert Bin to FPREG
    JR	VAL3
VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
VAL3:   POP     BC              ; Restore end+1 byte
        POP     HL              ; Restore end+1 address
        ld      (HL),B          ; Put back original byte
        RET

LFRGNM: EX      DE,HL           ; Code string address to HL
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
MIDNUM: POP     BC              ; Get return address
        POP     DE              ; Get number supplied
        PUSH    BC              ; Re-save return address
        ld      B,E             ; Number to B
        RET


; JC ADDING CENTRAL INPSUB_SURROGATE FOR INP AND WAIT:
INPSUB_SURROGATE:
        push bc
        ld b,0  ; It would be nice to have this loaded with high byte
        ld a,(INPORT)
        ld c,a
        in a,(C) ; This should work.  On HD44780 it uses B as high address bits
        pop bc
        ret

INP:    
        CALL    MAKINT          ; Make it integer A
        ld      (INPORT),A      ; Set input port
;/ JC ADAPTING THIS TO HD64180/Z80180/Z180 PORT I/O
;        CALL    INPSUB          ; Get input from port
        call    INPSUB_SURROGATE   ;JC replacing INPSUB
        JP      PASSA           ; Return integer A

POUT:
        ;/ JC ADAPTING THIS TO HD64180/Z80180/Z180 PORT I/O
        CALL    SETIO           ; Set up port number
;        JP      OUTSUB          ; Output data and return
        push BC
        push af
        ld b,0  ; It would be nice to have this loaded with high byte
        ld a,(OTPORT)
        ld c,a
        pop af
        OUT (c),a ; This should work.  On HD44780 it uses B as high address bits
        pop bc
        ret

WAIT:   CALL    SETIO           ; Set up port number
        PUSH    AF              ; Save AND mask
        ld      E,0             ; Assume zero if none given
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      Z,NOXOR         ; No XOR byte given
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255 to XOR with
NOXOR:  POP     BC              ; Restore AND mask
WAITLP:
;/ JC ADAPTING THIS TO HD64180/Z80180/Z180 PORT I/O
;        CALL    INPSUB          ; Get input
        call    INPSUB_SURROGATE   ;JC replacing INPSUB
        XOR     E               ; Flip selected bits
        AND     B               ; Result non-zero?
        JP      Z,WAITLP        ; No = keep waiting
        RET

; JC SAYS THIS WILL EVENTUALLY NEED TO BE CHANGED TO 16-BIT FOR HD64180
SETIO:  CALL    GETINT          ; Get integer 0-255
        ld      (INPORT),A      ; Set input port
        ld      (OTPORT),A      ; Set output port
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        JP      GETINT          ; Get integer 0-255 and return

FNDNUM: CALL    GETCHR          ; Get next character
GETINT: CALL    GETNUM          ; Get a number from 0 to 255
MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
        ld      A,D             ; Get MSB of number
        OR      A               ; Zero?
        JP      NZ,FCERR        ; No - Error
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        ld      A,E             ; Get number to A
        RET

PEEK:   CALL    DEINT           ; Get memory address
        ld      A,(DE)          ; Get byte in memory
        JP      PASSA           ; Return integer A

POKE:   CALL    GETNUM          ; Get memory address
        CALL    DEINT           ; Get integer -32768 to 3276
        PUSH    DE              ; Save memory address
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255
        POP     DE              ; Restore memory address
        ld      (DE),A          ; Load it into memory
        RET

ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
        JP      FPADD           ; Add BCDE to FPREG

SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
        .BYTE      21H             ; Skip "POP BC" and "POP DE"
PSUB:   POP     BC              ; Get FP number from stack
        POP     DE
SUBCDE: CALL    INVSGN          ; Negate FPREG
FPADD:  ld      A,B             ; Get FP exponent
        OR      A               ; Is number zero?
        RET     Z               ; Yes - Nothing to add
        ld      A,(FPEXP)       ; Get FPREG exponent
        OR      A               ; Is this number zero?
        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
        SUB     B               ; BCDE number larger?
        JP      NC,NOSWAP       ; No - Don't swap them
        CPL                     ; Two's complement
        INC     A               ;  FP exponent
        EX      DE,HL
        CALL    STAKFP          ; Put FPREG on stack
        EX      DE,HL
        CALL    FPBCDE          ; Move BCDE to FPREG
        POP     BC              ; Restore number from stack
        POP     DE
NOSWAP: CP      24+1            ; Second number insignificant?
        RET     NC              ; Yes - First number is result
        PUSH    AF              ; Save number of bits to scale
        CALL    SIGNS           ; Set MSBs & sign of result
        ld      H,A             ; Save sign of result
        POP     AF              ; Restore scaling factor
        CALL    SCALE           ; Scale BCDE to same exponent
        OR      H               ; Result to be positive?
        ld      HL,FPREG        ; Point to FPREG
        JP      P,MINCDE        ; No - Subtract FPREG from CDE
        CALL    PLUCDE          ; Add FPREG to CDE
        JP      NC,RONDUP       ; No overflow - Round it up
        INC     HL              ; Point to exponent
        INC     (HL)            ; Increment it
        JP      Z,OVERR         ; Number overflowed - Error
        ld      L,1             ; 1 bit to shift right
        CALL    SHRT1           ; Shift result right
        JP      RONDUP          ; Round it up

MINCDE: XOR     A               ; Clear A and carry
        SUB     B               ; Negate exponent
        ld      B,A             ; Re-save exponent
        ld      A,(HL)          ; Get LSB of FPREG
        SBC     A, E            ; Subtract LSB of BCDE
        ld      E,A             ; Save LSB of BCDE
        INC     HL
        ld      A,(HL)          ; Get NMSB of FPREG
        SBC     A,D             ; Subtract NMSB of BCDE
        ld      D,A             ; Save NMSB of BCDE
        INC     HL
        ld      A,(HL)          ; Get MSB of FPREG
        SBC     A,C             ; Subtract MSB of BCDE
        ld      C,A             ; Save MSB of BCDE
CONPOS: CALL    C,COMPL         ; Overflow - Make it positive

BNORM:  ld      L,B             ; L = Exponent
        ld      H,E             ; H = LSB
        XOR     A
BNRMLP: ld      B,A             ; Save bit count
        ld      A,C             ; Get MSB
        OR      A               ; Is it zero?
        JP      NZ,PNORM        ; No - Do it bit at a time
        ld      C,D             ; MSB = NMSB
        ld      D,H             ; NMSB= LSB
        ld      H,L             ; LSB = VLSB
        ld      L,A             ; VLSB= 0
        ld      A,B             ; Get exponent
        SUB     8               ; Count 8 bits
        CP      -24-8           ; Was number zero?
        JP      NZ,BNRMLP       ; No - Keep normalising
RESZER: XOR     A               ; Result is zero
SAVEXP: ld      (FPEXP),A       ; Save result as zero
        RET

NORMAL: DEC     B               ; Count bits
        ADD     HL,HL           ; Shift HL left
        ld      A,D             ; Get NMSB
        RLA                     ; Shift left with last bit
        ld      D,A             ; Save NMSB
        ld      A,C             ; Get MSB
        ADC     A,A             ; Shift left with last bit
        ld      C,A             ; Save MSB
PNORM:  JP      P,NORMAL        ; Not done - Keep going
        ld      A,B             ; Number of bits shifted
        ld      E,H             ; Save HL in EB
        ld      B,L
        OR      A               ; Any shifting done?
        JP      Z,RONDUP        ; No - Round it up
        ld      HL,FPEXP        ; Point to exponent
        ADD     A,(HL)          ; Add shifted bits
        ld      (HL),A          ; Re-save exponent
        JP      NC,RESZER       ; Underflow - Result is zero
        RET     Z               ; Result is zero
RONDUP: ld      A,B             ; Get VLSB of number
RONDB:  ld      HL,FPEXP        ; Point to exponent
        OR      A               ; Any rounding?
        CALL    M,FPROND        ; Yes - Round number up
        ld      B,(HL)          ; B = Exponent
        INC     HL
        ld      A,(HL)          ; Get sign of result
        AND     10000000B       ; Only bit 7 needed
        XOR     C               ; Set correct sign
        ld      C,A             ; Save correct sign in number
        JP      FPBCDE          ; Move BCDE to FPREG

FPROND: INC     E               ; Round LSB
        RET     NZ              ; Return if ok
        INC     D               ; Round NMSB
        RET     NZ              ; Return if ok
        INC     C               ; Round MSB
        RET     NZ              ; Return if ok
        ld      C,80H           ; Set normal value
        INC     (HL)            ; Increment exponent
        RET     NZ              ; Return if ok
        JP      OVERR           ; Overflow error

PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
        ADD     A,E             ; Add LSB of BCDE
        ld      E,A             ; Save LSB of BCDE
        INC     HL
        ld      A,(HL)          ; Get NMSB of FPREG
        ADC     A,D             ; Add NMSB of BCDE
        ld      D,A             ; Save NMSB of BCDE
        INC     HL
        ld      A,(HL)          ; Get MSB of FPREG
        ADC     A,C             ; Add MSB of BCDE
        ld      C,A             ; Save MSB of BCDE
        RET

COMPL:  ld      HL,SGNRES       ; Sign of result
        ld      A,(HL)          ; Get sign of result
        CPL                     ; Negate it
        ld      (HL),A          ; Put it back
        XOR     A
        ld      L,A             ; Set L to zero
        SUB     B               ; Negate exponent,set carry
        ld      B,A             ; Re-save exponent
        ld      A,L             ; Load zero
        SBC     A,E             ; Negate LSB
        ld      E,A             ; Re-save LSB
        ld      A,L             ; Load zero
        SBC     A,D             ; Negate NMSB
        ld      D,A             ; Re-save NMSB
        ld      A,L             ; Load zero
        SBC     A,C             ; Negate MSB
        ld      C,A             ; Re-save MSB
        RET

SCALE:  ld      B,0             ; Clear underflow
SCALLP: SUB     8               ; 8 bits (a whole byte)?
        JP      C,SHRITE        ; No - Shift right A bits
        ld      B,E             ; <- Shift
        ld      E,D             ; <- right
        ld      D,C             ; <- eight
        ld      C,0             ; <- bits
        JP      SCALLP          ; More bits to shift

SHRITE: ADD     A,8+1           ; Adjust count
        ld      L,A             ; Save bits to shift
SHRLP:  XOR     A               ; Flag for all done
        DEC     L               ; All shifting done?
        RET     Z               ; Yes - Return
        ld      A,C             ; Get MSB
SHRT1:  RRA                     ; Shift it right
        ld      C,A             ; Re-save
        ld      A,D             ; Get NMSB
        RRA                     ; Shift right with last bit
        ld      D,A             ; Re-save it
        ld      A,E             ; Get LSB
        RRA                     ; Shift right with last bit
        ld      E,A             ; Re-save it
        ld      A,B             ; Get underflow
        RRA                     ; Shift right with last bit
        ld      B,A             ; Re-save underflow
        JP      SHRLP           ; More bits to do

UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000

LOGTAB: .BYTE      3                       ; Table used by LOG
        .BYTE      0AAH,056H,019H,080H     ; 0.59898
        .BYTE      0F1H,022H,076H,080H     ; 0.96147
        .BYTE      045H,0AAH,038H,082H     ; 2.88539

LOG:    CALL    TSTSGN          ; Test sign of value
        OR      A
        JP      PE,FCERR        ; ?FC Error if <= zero
        ld      HL,FPEXP        ; Point to exponent
        ld      A,(HL)          ; Get exponent
        ld      BC,8035H        ; BCDE = SQR(1/2)
        ld      DE,04F3H
        SUB     B               ; Scale value to be < 1
        PUSH    AF              ; Save scale factor
        ld      (HL),B          ; Save new exponent
        PUSH    DE              ; Save SQR(1/2)
        PUSH    BC
        CALL    FPADD           ; Add SQR(1/2) to value
        POP     BC              ; Restore SQR(1/2)
        POP     DE
        INC     B               ; Make it SQR(2)
        CALL    DVBCDE          ; Divide by SQR(2)
        ld      HL,UNITY        ; Point to 1.
        CALL    SUBPHL          ; Subtract FPREG from 1
        ld      HL,LOGTAB       ; Coefficient table
        CALL    SUMSER          ; Evaluate sum of series
        ld      BC,8080H        ; BCDE = -0.5
        ld      DE,0000H
        CALL    FPADD           ; Subtract 0.5 from FPREG
        POP     AF              ; Restore scale factor
        CALL    RSCALE          ; Re-scale number
MULLN2: ld      BC,8031H        ; BCDE = Ln(2)
        ld      DE,7218H
        .BYTE      21H             ; Skip "POP BC" and "POP DE"

MULT:   POP     BC              ; Get number from stack
        POP     DE
FPMULT: CALL    TSTSGN          ; Test sign of FPREG
        RET     Z               ; Return zero if zero
        ld      L,0             ; Flag add exponents
        CALL    ADDEXP          ; Add exponents
        ld      A,C             ; Get MSB of multiplier
        ld      (MULVAL),A      ; Save MSB of multiplier
        EX      DE,HL
        ld      (MULVAL+1),HL   ; Save rest of multiplier
        ld      BC,0            ; Partial product (BCDE) = zero
        ld      D,B
        ld      E,B
        ld      HL,BNORM        ; Address of normalise
        PUSH    HL              ; Save for return
        ld      HL,MULT8        ; Address of 8 bit multiply
        PUSH    HL              ; Save for NMSB,MSB
        PUSH    HL              ; 
        ld      HL,FPREG        ; Point to number
MULT8:  ld      A,(HL)          ; Get LSB of number
        INC     HL              ; Point to NMSB
        OR      A               ; Test LSB
        JP      Z,BYTSFT        ; Zero - shift to next byte
        PUSH    HL              ; Save address of number
        ld      L,8             ; 8 bits to multiply by
MUL8LP: RRA                     ; Shift LSB right
        ld      H,A             ; Save LSB
        ld      A,C             ; Get MSB
        JP      NC,NOMADD       ; Bit was zero - Don't add
        PUSH    HL              ; Save LSB and count
        ld      HL,(MULVAL+1)   ; Get LSB and NMSB
        ADD     HL,DE           ; Add NMSB and LSB
        EX      DE,HL           ; Leave sum in DE
        POP     HL              ; Restore MSB and count
        ld      A,(MULVAL)      ; Get MSB of multiplier
        ADC     A,C             ; Add MSB
NOMADD: RRA                     ; Shift MSB right
        ld      C,A             ; Re-save MSB
        ld      A,D             ; Get NMSB
        RRA                     ; Shift NMSB right
        ld      D,A             ; Re-save NMSB
        ld      A,E             ; Get LSB
        RRA                     ; Shift LSB right
        ld      E,A             ; Re-save LSB
        ld      A,B             ; Get VLSB
        RRA                     ; Shift VLSB right
        ld      B,A             ; Re-save VLSB
        DEC     L               ; Count bits multiplied
        ld      A,H             ; Get LSB of multiplier
        JP      NZ,MUL8LP       ; More - Do it
POPHRT: POP     HL              ; Restore address of number
        RET

BYTSFT: ld      B,E             ; Shift partial product left
        ld      E,D
        ld      D,C
        ld      C,A
        RET

DIV10:  CALL    STAKFP          ; Save FPREG on stack
        ld      BC,8420H        ; BCDE = 10.
        ld      DE,0000H
        CALL    FPBCDE          ; Move 10 to FPREG

DIV:    POP     BC              ; Get number from stack
        POP     DE
DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
        JP      Z,DZERR         ; Error if division by zero
        ld      L,-1            ; Flag subtract exponents
        CALL    ADDEXP          ; Subtract exponents
        INC     (HL)            ; Add 2 to exponent to adjust
        INC     (HL)
        DEC     HL              ; Point to MSB
        ld      A,(HL)          ; Get MSB of dividend
        ld      (DIV3),A        ; Save for subtraction
        DEC     HL
        ld      A,(HL)          ; Get NMSB of dividend
        ld      (DIV2),A        ; Save for subtraction
        DEC     HL
        ld      A,(HL)          ; Get MSB of dividend
        ld      (DIV1),A        ; Save for subtraction
        ld      B,C             ; Get MSB
        EX      DE,HL           ; NMSB,LSB to HL
        XOR     A
        ld      C,A             ; Clear MSB of quotient
        ld      D,A             ; Clear NMSB of quotient
        ld      E,A             ; Clear LSB of quotient
        ld      (DIV4),A        ; Clear overflow count
DIVLP:  PUSH    HL              ; Save divisor
        PUSH    BC
        ld      A,L             ; Get LSB of number
        CALL    DIVSUP          ; Subt' divisor from dividend
        SBC     A,0             ; Count for overflows
        CCF
        JP      NC,RESDIV       ; Restore divisor if borrow
        ld      (DIV4),A        ; Re-save overflow count
        POP     AF              ; Scrap divisor
        POP     AF
        SCF                     ; Set carry to
        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"

RESDIV: POP     BC              ; Restore divisor
        POP     HL
        ld      A,C             ; Get MSB of quotient
        INC     A
        DEC     A
        RRA                     ; Bit 0 to bit 7
        JP      M,RONDB         ; Done - Normalise result
        RLA                     ; Restore carry
        ld      A,E             ; Get LSB of quotient
        RLA                     ; Double it
        ld      E,A             ; Put it back
        ld      A,D             ; Get NMSB of quotient
        RLA                     ; Double it
        ld      D,A             ; Put it back
        ld      A,C             ; Get MSB of quotient
        RLA                     ; Double it
        ld      C,A             ; Put it back
        ADD     HL,HL           ; Double NMSB,LSB of divisor
        ld      A,B             ; Get MSB of divisor
        RLA                     ; Double it
        ld      B,A             ; Put it back
        ld      A,(DIV4)        ; Get VLSB of quotient
        RLA                     ; Double it
        ld      (DIV4),A        ; Put it back
        ld      A,C             ; Get MSB of quotient
        OR      D               ; Merge NMSB
        OR      E               ; Merge LSB
        JP      NZ,DIVLP        ; Not done - Keep dividing
        PUSH    HL              ; Save divisor
        ld      HL,FPEXP        ; Point to exponent
        DEC     (HL)            ; Divide by 2
        POP     HL              ; Restore divisor
        JP      NZ,DIVLP        ; Ok - Keep going
        JP      OVERR           ; Overflow error

ADDEXP: ld      A,B             ; Get exponent of dividend
        OR      A               ; Test it
        JP      Z,OVTST3        ; Zero - Result zero
        ld      A,L             ; Get add/subtract flag
        ld      HL,FPEXP        ; Point to exponent
        XOR     (HL)            ; Add or subtract it
        ADD     A,B             ; Add the other exponent
        ld      B,A             ; Save new exponent
        RRA                     ; Test exponent for overflow
        XOR     B
        ld      A,B             ; Get exponent
        JP      P,OVTST2        ; Positive - Test for overflow
        ADD     A,80H           ; Add excess 128
        ld      (HL),A          ; Save new exponent
        JP      Z,POPHRT        ; Zero - Result zero
        CALL    SIGNS           ; Set MSBs and sign of result
        ld      (HL),A          ; Save new exponent
        DEC     HL              ; Point to MSB
        RET

OVTST1: CALL    TSTSGN          ; Test sign of FPREG
        CPL                     ; Invert sign
        POP     HL              ; Clean up stack
OVTST2: OR      A               ; Test if new exponent zero
OVTST3: POP     HL              ; Clear off return address
        JP      P,RESZER        ; Result zero
        JP      OVERR           ; Overflow error

MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
        ld      A,B             ; Get exponent
        OR      A               ; Is it zero?
        RET     Z               ; Yes - Result is zero
        ADD     A,2             ; Multiply by 4
        JP      C,OVERR         ; Overflow - ?OV Error
        ld      B,A             ; Re-save exponent
        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
        ld      HL,FPEXP        ; Point to exponent
        INC     (HL)            ; Double number (Times 10)
        RET     NZ              ; Ok - Return
        JP      OVERR           ; Overflow error

TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
        OR      A
        RET     Z               ; RETurn if number is zero
        ld      A,(FPREG+2)     ; Get MSB of FPREG
        .BYTE      0FEH            ; Test sign
RETREL: CPL                     ; Invert sign
        RLA                     ; Sign bit to carry
FLGDIF: SBC     A,A             ; Carry to all bits of A
        RET     NZ              ; Return -1 if negative
        INC     A               ; Bump to +1
        RET                     ; Positive - Return +1

SGN:    CALL    TSTSGN          ; Test sign of FPREG
FLGREL: ld      B,80H+8         ; 8 bit integer in exponent
        ld      DE,0            ; Zero NMSB and LSB
RETINT: ld      HL,FPEXP        ; Point to exponent
        ld      C,A             ; CDE = MSB,NMSB and LSB
        ld      (HL),B          ; Save exponent
        ld      B,0             ; CDE = integer to normalise
        INC     HL              ; Point to sign of result
        ld      (HL),80H        ; Set sign of result
        RLA                     ; Carry = sign of integer
        JP      CONPOS          ; Set sign of result

ABS:    CALL    TSTSGN          ; Test sign of FPREG
        RET     P               ; Return if positive
INVSGN: ld      HL,FPREG+2      ; Point to MSB
        ld      A,(HL)          ; Get sign of mantissa
        XOR     80H             ; Invert sign of mantissa
        ld      (HL),A          ; Re-save sign of mantissa
        RET

STAKFP: EX      DE,HL           ; Save code string address
        ld      HL,(FPREG)      ; LSB,NLSB of FPREG
        EX      (SP),HL         ; Stack them,get return
        PUSH    HL              ; Re-save return
        ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
        EX      (SP),HL         ; Stack them,get return
        PUSH    HL              ; Re-save return
        EX      DE,HL           ; Restore code string address
        RET

PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
FPBCDE: EX      DE,HL           ; Save code string address
        ld      (FPREG),HL      ; Save LSB,NLSB of number
        ld      H,B             ; Exponent of number
        ld      L,C             ; MSB of number
        ld      (FPREG+2),HL    ; Save MSB and exponent
        EX      DE,HL           ; Restore code string address
        RET

BCDEFP: ld      HL,FPREG        ; Point to FPREG
LOADFP: ld      E,(HL)          ; Get LSB of number
        INC     HL
        ld      D,(HL)          ; Get NMSB of number
        INC     HL
        ld      C,(HL)          ; Get MSB of number
        INC     HL
        ld      B,(HL)          ; Get exponent of number
INCHL:  INC     HL              ; Used for conditional "INC HL"
        RET

FPTHL:  ld      DE,FPREG        ; Point to FPREG
DETHL4: ld      B,4             ; 4 bytes to move
DETHLB: ld      A,(DE)          ; Get source
        ld      (HL),A          ; Save destination
        INC     DE              ; Next source
        INC     HL              ; Next destination
        DEC     B               ; Count bytes
        JP      NZ,DETHLB       ; Loop if more
        RET

SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
        ld      A,(HL)          ; Get MSB
        RLCA                    ; Old sign to carry
        SCF                     ; Set MSBit
        RRA                     ; Set MSBit of MSB
        ld      (HL),A          ; Save new MSB
        CCF                     ; Complement sign
        RRA                     ; Old sign to carry
        INC     HL
        INC     HL
        ld      (HL),A          ; Set sign of result
        ld      A,C             ; Get MSB
        RLCA                    ; Old sign to carry
        SCF                     ; Set MSBit
        RRA                     ; Set MSBit of MSB
        ld      C,A             ; Save MSB
        RRA
        XOR     (HL)            ; New sign of result
        RET

CMPNUM: ld      A,B             ; Get exponent of number
        OR      A
        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
        ld      HL,RETREL       ; Return relation routine
        PUSH    HL              ; Save for return
        CALL    TSTSGN          ; Test sign of FPREG
        ld      A,C             ; Get MSB of number
        RET     Z               ; FPREG zero - Number's MSB
        ld      HL,FPREG+2      ; MSB of FPREG
        XOR     (HL)            ; Combine signs
        ld      A,C             ; Get MSB of number
        RET     M               ; Exit if signs different
        CALL    CMPFP           ; Compare FP numbers
        RRA                     ; Get carry to sign
        XOR     C               ; Combine with MSB of number
        RET

CMPFP:  INC     HL              ; Point to exponent
        ld      A,B             ; Get exponent
        CP      (HL)            ; Compare exponents
        RET     NZ              ; Different
        DEC     HL              ; Point to MBS
        ld      A,C             ; Get MSB
        CP      (HL)            ; Compare MSBs
        RET     NZ              ; Different
        DEC     HL              ; Point to NMSB
        ld      A,D             ; Get NMSB
        CP      (HL)            ; Compare NMSBs
        RET     NZ              ; Different
        DEC     HL              ; Point to LSB
        ld      A,E             ; Get LSB
        SUB     (HL)            ; Compare LSBs
        RET     NZ              ; Different
        POP     HL              ; Drop RETurn
        POP     HL              ; Drop another RETurn
        RET

FPINT:  ld      B,A             ; <- Move
        ld      C,A             ; <- exponent
        ld      D,A             ; <- to all
        ld      E,A             ; <- bits
        OR      A               ; Test exponent
        RET     Z               ; Zero - Return zero
        PUSH    HL              ; Save pointer to number
        CALL    BCDEFP          ; Move FPREG to BCDE
        CALL    SIGNS           ; Set MSBs & sign of result
        XOR     (HL)            ; Combine with sign of FPREG
        ld      H,A             ; Save combined signs
        CALL    M,DCBCDE        ; Negative - Decrement BCDE
        ld      A,80H+24        ; 24 bits
        SUB     B               ; Bits to shift
        CALL    SCALE           ; Shift BCDE
        ld      A,H             ; Get combined sign
        RLA                     ; Sign to carry
        CALL    C,FPROND        ; Negative - Round number up
        ld      B,0             ; Zero exponent
        CALL    C,COMPL         ; If negative make positive
        POP     HL              ; Restore pointer to number
        RET

DCBCDE: DEC     DE              ; Decrement BCDE
        ld      A,D             ; Test LSBs
        AND     E
        INC     A
        RET     NZ              ; Exit if LSBs not FFFF
        DEC     BC              ; Decrement MSBs
        RET

INT:    ld      HL,FPEXP        ; Point to exponent
        ld      A,(HL)          ; Get exponent
        CP      80H+24          ; Integer accuracy only?
        ld      A,(FPREG)       ; Get LSB
        RET     NC              ; Yes - Already integer
        ld      A,(HL)          ; Get exponent
        CALL    FPINT           ; F.P to integer
        ld      (HL),80H+24     ; Save 24 bit integer
        ld      A,E             ; Get LSB of number
        PUSH    AF              ; Save LSB
        ld      A,C             ; Get MSB of number
        RLA                     ; Sign to carry
        CALL    CONPOS          ; Set sign of result
        POP     AF              ; Restore LSB of number
        RET

MLDEBC: ld      HL,0            ; Clear partial product
        ld      A,B             ; Test multiplier
        OR      C
        RET     Z               ; Return zero if zero
        ld      A,16            ; 16 bits
MLDBLP: ADD     HL,HL           ; Shift P.P left
        JP      C,BSERR         ; ?BS Error if overflow
        EX      DE,HL
        ADD     HL,HL           ; Shift multiplier left
        EX      DE,HL
        JP      NC,NOMLAD       ; Bit was zero - No add
        ADD     HL,BC           ; Add multiplicand
        JP      C,BSERR         ; ?BS Error if overflow
NOMLAD: DEC     A               ; Count bits
        JP      NZ,MLDBLP       ; More
        RET

ASCTFP: CP      '-'             ; Negative?
        PUSH    AF              ; Save it and flags
        JP      Z,CNVNUM        ; Yes - Convert number
        CP      '+'             ; Positive?
        JP      Z,CNVNUM        ; Yes - Convert number
        DEC     HL              ; DEC 'cos GETCHR INCs
CNVNUM: CALL    RESZER          ; Set result to zero
        ld      B,A             ; Digits after point counter
        ld      D,A             ; Sign of exponent
        ld      E,A             ; Exponent of ten
        CPL
        ld      C,A             ; Before or after point flag
MANLP:  CALL    GETCHR          ; Get next character
        JP      C,ADDIG         ; Digit - Add to number
        CP      '.'
        JP      Z,DPOINT        ; '.' - Flag point
        CP      'E'
        JP      NZ,CONEXP       ; Not 'E' - Scale number
        CALL    GETCHR          ; Get next character
        CALL    SGNEXP          ; Get sign of exponent
EXPLP:  CALL    GETCHR          ; Get next character
        JP      C,EDIGIT        ; Digit - Add to exponent
        INC     D               ; Is sign negative?
        JP      NZ,CONEXP       ; No - Scale number
        XOR     A
        SUB     E               ; Negate exponent
        ld      E,A             ; And re-save it
        INC     C               ; Flag end of number
DPOINT: INC     C               ; Flag point passed
        JP      Z,MANLP         ; Zero - Get another digit
CONEXP: PUSH    HL              ; Save code string address
        ld      A,E             ; Get exponent
        SUB     B               ; Subtract digits after point
SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
        JP      P,ENDCON        ; Positive - All done
        PUSH    AF              ; Save number of times to /10
        CALL    DIV10           ; Divide by 10
        POP     AF              ; Restore count
        INC     A               ; Count divides

ENDCON: JP      NZ,SCALMI       ; More to do
        POP     DE              ; Restore code string address
        POP     AF              ; Restore sign of number
        CALL    Z,INVSGN        ; Negative - Negate number
        EX      DE,HL           ; Code string address to HL
        RET

SCALPL: RET     Z               ; Exit if no scaling needed
MULTEN: PUSH    AF              ; Save count
        CALL    MLSP10          ; Multiply number by 10
        POP     AF              ; Restore count
        DEC     A               ; Count multiplies
        RET

ADDIG:  PUSH    DE              ; Save sign of exponent
        ld      D,A             ; Save digit
        ld      A,B             ; Get digits after point
        ADC     A,C             ; Add one if after point
        ld      B,A             ; Re-save counter
        PUSH    BC              ; Save point flags
        PUSH    HL              ; Save code string address
        PUSH    DE              ; Save digit
        CALL    MLSP10          ; Multiply number by 10
        POP     AF              ; Restore digit
        SUB     '0'             ; Make it absolute
        CALL    RSCALE          ; Re-scale number
        POP     HL              ; Restore code string address
        POP     BC              ; Restore point flags
        POP     DE              ; Restore sign of exponent
        JP      MANLP           ; Get another digit

RSCALE: CALL    STAKFP          ; Put number on stack
        CALL    FLGREL          ; Digit to add to FPREG
PADD:   POP     BC              ; Restore number
        POP     DE
        JP      FPADD           ; Add BCDE to FPREG and return

EDIGIT: ld      A,E             ; Get digit
        RLCA                    ; Times 2
        RLCA                    ; Times 4
        ADD     A,E             ; Times 5
        RLCA                    ; Times 10
        ADD     A,(HL)          ; Add next digit
        SUB     '0'             ; Make it absolute
        ld      E,A             ; Save new digit
        JP      EXPLP           ; Look for another digit

LINEIN: PUSH    HL              ; Save code string address
        ld      HL,INMSG        ; Output " in "
        CALL    PRS             ; Output string at HL
        POP     HL              ; Restore code string address
PRNTHL: EX      DE,HL           ; Code string address to DE
        XOR     A
        ld      B,80H+24        ; 24 bits
        CALL    RETINT          ; Return the integer
        ld      HL,PRNUMS       ; Print number string
        PUSH    HL              ; Save for return
NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
        PUSH    HL              ; Save for return
        CALL    TSTSGN          ; Test sign of FPREG
        ld      (HL),' '        ; Space at start
        JP      P,SPCFST        ; Positive - Space to start
        ld      (HL),'-'        ; '-' sign at start
SPCFST: INC     HL              ; First byte of number
        ld      (HL),'0'        ; '0' if zero
        JP      Z,JSTZER        ; Return '0' if zero
        PUSH    HL              ; Save buffer address
        CALL    M,INVSGN        ; Negate FPREG if negative
        XOR     A               ; Zero A
        PUSH    AF              ; Save it
        CALL    RNGTST          ; Test number is in range
SIXDIG: ld      BC,9143H        ; BCDE - 99999.9
        ld      DE,4FF8H
        CALL    CMPNUM          ; Compare numbers
        OR      A
        JP      PO,INRNG        ; > 99999.9 - Sort it out
        POP     AF              ; Restore count
        CALL    MULTEN          ; Multiply by ten
        PUSH    AF              ; Re-save count
        JP      SIXDIG          ; Test it again

GTSIXD: CALL    DIV10           ; Divide by 10
        POP     AF              ; Get count
        INC     A               ; Count divides
        PUSH    AF              ; Re-save count
        CALL    RNGTST          ; Test number is in range
INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
        INC     A
        CALL    FPINT           ; F.P to integer
        CALL    FPBCDE          ; Move BCDE to FPREG
        ld      BC,0306H        ; 1E+06 to 1E-03 range
        POP     AF              ; Restore count
        ADD     A,C             ; 6 digits before point
        INC     A               ; Add one
        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
        CP      6+1+1           ; More than 999999 ?
        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
        INC     A               ; Adjust for exponent
        ld      B,A             ; Exponent of number
        ld      A,2             ; Make it zero after

MAKNUM: DEC     A               ; Adjust for digits to do
        DEC     A
        POP     HL              ; Restore buffer address
        PUSH    AF              ; Save count
        ld      DE,POWERS       ; Powers of ten
        DEC     B               ; Count digits before point
        JP      NZ,DIGTXT       ; Not zero - Do number
        ld      (HL),'.'        ; Save point
        INC     HL              ; Move on
        ld      (HL),'0'        ; Save zero
        INC     HL              ; Move on
DIGTXT: DEC     B               ; Count digits before point
        ld      (HL),'.'        ; Save point in case
        CALL    Z,INCHL         ; Last digit - move on
        PUSH    BC              ; Save digits before point
        PUSH    HL              ; Save buffer address
        PUSH    DE              ; Save powers of ten
        CALL    BCDEFP          ; Move FPREG to BCDE
        POP     HL              ; Powers of ten table
        ld      B, '0'-1        ; ASCII '0' - 1
TRYAGN: INC     B               ; Count subtractions
        ld      A,E             ; Get LSB
        SUB     (HL)            ; Subtract LSB
        ld      E,A             ; Save LSB
        INC     HL
        ld      A,D             ; Get NMSB
        SBC     A,(HL)          ; Subtract NMSB
        ld      D,A             ; Save NMSB
        INC     HL
        ld      A,C             ; Get MSB
        SBC     A,(HL)          ; Subtract MSB
        ld      C,A             ; Save MSB
        DEC     HL              ; Point back to start
        DEC     HL
        JP      NC,TRYAGN       ; No overflow - Try again
        CALL    PLUCDE          ; Restore number
        INC     HL              ; Start of next number
        CALL    FPBCDE          ; Move BCDE to FPREG
        EX      DE,HL           ; Save point in table
        POP     HL              ; Restore buffer address
        ld      (HL),B          ; Save digit in buffer
        INC     HL              ; And move on
        POP     BC              ; Restore digit count
        DEC     C               ; Count digits
        JP      NZ,DIGTXT       ; More - Do them
        DEC     B               ; Any decimal part?
        JP      Z,DOEBIT        ; No - Do 'E' bit
SUPTLZ: DEC     HL              ; Move back through buffer
        ld      A,(HL)          ; Get character
        CP      '0'             ; '0' character?
        JP      Z,SUPTLZ        ; Yes - Look back for more
        CP      '.'             ; A decimal point?
        CALL    NZ,INCHL        ; Move back over digit

DOEBIT: POP     AF              ; Get 'E' flag
        JP      Z,NOENED        ; No 'E' needed - End buffer
        ld      (HL),'E'        ; Put 'E' in buffer
        INC     HL              ; And move on
        ld      (HL),'+'        ; Put '+' in buffer
        JP      P,OUTEXP        ; Positive - Output exponent
        ld      (HL),'-'        ; Put '-' in buffer
        CPL                     ; Negate exponent
        INC     A
OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
EXPTEN: INC     B               ; Count subtractions
        SUB     10              ; Tens digit
        JP      NC,EXPTEN       ; More to do
        ADD     A,'0'+10        ; Restore and make ASCII
        INC     HL              ; Move on
        ld      (HL),B          ; Save MSB of exponent
JSTZER: INC     HL              ;
        ld      (HL),A          ; Save LSB of exponent
        INC     HL
NOENED: ld      (HL),C          ; Mark end of buffer
        POP     HL              ; Restore code string address
        RET

RNGTST: ld      BC,9474H        ; BCDE = 999999.
        ld      DE,23F7H
        CALL    CMPNUM          ; Compare numbers
        OR      A
        POP     HL              ; Return address to HL
        JP      PO,GTSIXD       ; Too big - Divide by ten
        JP      (HL)            ; Otherwise return to caller

HALF:   .BYTE      00H,00H,00H,80H ; 0.5

POWERS: .BYTE      0A0H,086H,001H  ; 100000
        .BYTE      010H,027H,000H  ;  10000
        .BYTE      0E8H,003H,000H  ;   1000
        .BYTE      064H,000H,000H  ;    100
        .BYTE      00AH,000H,000H  ;     10
        .BYTE      001H,000H,000H  ;      1

NEGAFT: ld  HL,INVSGN           ; Negate result
        EX      (SP),HL         ; To be done after caller
        JP      (HL)            ; Return to caller

SQR:    CALL    STAKFP          ; Put value on stack
        ld      HL,HALF         ; Set power to 1/2
        CALL    PHLTFP          ; Move 1/2 to FPREG

POWER:  POP     BC              ; Get base
        POP     DE
        CALL    TSTSGN          ; Test sign of power
        ld      A,B             ; Get exponent of base
        JP      Z,EXP           ; Make result 1 if zero
        JP      P,POWER1        ; Positive base - Ok
        OR      A               ; Zero to negative power?
        JP      Z,DZERR         ; Yes - ?/0 Error
POWER1: OR      A               ; Base zero?
        JP      Z,SAVEXP        ; Yes - Return zero
        PUSH    DE              ; Save base
        PUSH    BC
        ld      A,C             ; Get MSB of base
        OR      01111111B       ; Get sign status
        CALL    BCDEFP          ; Move power to BCDE
        JP      P,POWER2        ; Positive base - Ok
        PUSH    DE              ; Save power
        PUSH    BC
        CALL    INT             ; Get integer of power
        POP     BC              ; Restore power
        POP     DE
        PUSH    AF              ; MSB of base
        CALL    CMPNUM          ; Power an integer?
        POP     HL              ; Restore MSB of base
        ld      A,H             ; but don't affect flags
        RRA                     ; Exponent odd or even?
POWER2: POP     HL              ; Restore MSB and exponent
        ld      (FPREG+2),HL    ; Save base in FPREG
        POP     HL              ; LSBs of base
        ld      (FPREG),HL      ; Save in FPREG
        CALL    C,NEGAFT        ; Odd power - Negate result
        CALL    Z,INVSGN        ; Negative base - Negate it
        PUSH    DE              ; Save power
        PUSH    BC
        CALL    LOG             ; Get LOG of base
        POP     BC              ; Restore power
        POP     DE
        CALL    FPMULT          ; Multiply LOG by power

EXP:    CALL    STAKFP          ; Put value on stack
        ld      BC,08138H       ; BCDE = 1/Ln(2)
        ld      DE,0AA3BH
        CALL    FPMULT          ; Multiply value by 1/LN(2)
        ld      A,(FPEXP)       ; Get exponent
        CP      80H+8           ; Is it in range?
        JP      NC,OVTST1       ; No - Test for overflow
        CALL    INT             ; Get INT of FPREG
        ADD     A,80H           ; For excess 128
        ADD     A,2             ; Exponent > 126?
        JP      C,OVTST1        ; Yes - Test for overflow
        PUSH    AF              ; Save scaling factor
        ld      HL,UNITY        ; Point to 1.
        CALL    ADDPHL          ; Add 1 to FPREG
        CALL    MULLN2          ; Multiply by LN(2)
        POP     AF              ; Restore scaling factor
        POP     BC              ; Restore exponent
        POP     DE
        PUSH    AF              ; Save scaling factor
        CALL    SUBCDE          ; Subtract exponent from FPREG
        CALL    INVSGN          ; Negate result
        ld      HL,EXPTAB       ; Coefficient table
        CALL    SMSER1          ; Sum the series
        ld      DE,0            ; Zero LSBs
        POP     BC              ; Scaling factor
        ld      C,D             ; Zero MSB
        JP      FPMULT          ; Scale result to correct value

EXPTAB: .BYTE      8                       ; Table used by EXP
        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)

SUMSER: CALL    STAKFP          ; Put FPREG on stack
        ld      DE,MULT         ; Multiply by "X"
        PUSH    DE              ; To be done after
        PUSH    HL              ; Save address of table
        CALL    BCDEFP          ; Move FPREG to BCDE
        CALL    FPMULT          ; Square the value
        POP     HL              ; Restore address of table
SMSER1: CALL    STAKFP          ; Put value on stack
        ld      A,(HL)          ; Get number of coefficients
        INC     HL              ; Point to start of table
        CALL    PHLTFP          ; Move coefficient to FPREG
        .BYTE      06H             ; Skip "POP AF"
SUMLP:  POP     AF              ; Restore count
        POP     BC              ; Restore number
        POP     DE
        DEC     A               ; Cont coefficients
        RET     Z               ; All done
        PUSH    DE              ; Save number
        PUSH    BC
        PUSH    AF              ; Save count
        PUSH    HL              ; Save address in table
        CALL    FPMULT          ; Multiply FPREG by BCDE
        POP     HL              ; Restore address in table
        CALL    LOADFP          ; Number at HL to BCDE
        PUSH    HL              ; Save address in table
        CALL    FPADD           ; Add coefficient to FPREG
        POP     HL              ; Restore address in table
        JP      SUMLP           ; More coefficients

RND:    CALL    TSTSGN          ; Test sign of FPREG
        ld      HL,SEED+2       ; Random number seed
        JP      M,RESEED        ; Negative - Re-seed
        ld      HL,LSTRND       ; Last random number
        CALL    PHLTFP          ; Move last RND to FPREG
        ld      HL,SEED+2       ; Random number seed
        RET     Z               ; Return if RND(0)
        ADD     A,(HL)          ; Add (SEED)+2)
        AND     00000111B       ; 0 to 7
        ld      B,0
        ld      (HL),A          ; Re-save seed
        INC     HL              ; Move to coefficient table
        ADD     A,A             ; 4 bytes
        ADD     A,A             ; per entry
        ld      C,A             ; BC = Offset into table
        ADD     HL,BC           ; Point to coefficient
        CALL    LOADFP          ; Coefficient to BCDE
        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
        ld      A,(SEED+1)      ; Get (SEED+1)
        INC     A               ; Add 1
        AND     00000011B       ; 0 to 3
        ld      B,0
        CP      1               ; Is it zero?
        ADC     A,B             ; Yes - Make it 1
        ld      (SEED+1),A      ; Re-save seed
        ld      HL,RNDTAB-4     ; Addition table
        ADD     A,A             ; 4 bytes
        ADD     A,A             ; per entry
        ld      C,A             ; BC = Offset into table
        ADD     HL,BC           ; Point to value
        CALL    ADDPHL          ; Add value to FPREG
RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
        ld      A,E             ; Get LSB
        ld      E,C             ; LSB = MSB
        XOR     01001111B       ; Fiddle around
        ld      C,A             ; New MSB
        ld      (HL),80H        ; Set exponent
        DEC     HL              ; Point to MSB
        ld      B,(HL)          ; Get MSB
        ld      (HL),80H        ; Make value -0.5
        ld      HL,SEED         ; Random number seed
        INC     (HL)            ; Count seed
        ld      A,(HL)          ; Get seed
        SUB     171             ; Do it modulo 171
        JP      NZ,RND2         ; Non-zero - Ok
        ld      (HL),A          ; Zero seed
        INC     C               ; Fillde about
        DEC     D               ; with the
        INC     E               ; number
RND2:   CALL    BNORM           ; Normalise number
        ld      HL,LSTRND       ; Save random number
        JP      FPTHL           ; Move FPREG to last and return

RESEED: ld      (HL),A          ; Re-seed random numbers
        DEC     HL
        ld      (HL),A
        DEC     HL
        ld      (HL),A
        JP      RND1            ; Return RND seed

RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
        .BYTE   099H,0E9H,092H,069H
        .BYTE   010H,0D1H,075H,068H

COS:    ld      HL,HALFPI       ; Point to PI/2
        CALL    ADDPHL          ; Add it to PPREG
SIN:    CALL    STAKFP          ; Put angle on stack
        ld      BC,8349H        ; BCDE = 2 PI
        ld      DE,0FDBH
        CALL    FPBCDE          ; Move 2 PI to FPREG
        POP     BC              ; Restore angle
        POP     DE
        CALL    DVBCDE          ; Divide angle by 2 PI
        CALL    STAKFP          ; Put it on stack
        CALL    INT             ; Get INT of result
        POP     BC              ; Restore number
        POP     DE
        CALL    SUBCDE          ; Make it 0 <= value < 1
        ld      HL,QUARTR       ; Point to 0.25
        CALL    SUBPHL          ; Subtract value from 0.25
        CALL    TSTSGN          ; Test sign of value
        SCF                     ; Flag positive
        JP      P,SIN1          ; Positive - Ok
        CALL    ROUND           ; Add 0.5 to value
        CALL    TSTSGN          ; Test sign of value
        OR      A               ; Flag negative
SIN1:   PUSH    AF              ; Save sign
        CALL    P,INVSGN        ; Negate value if positive
        ld      HL,QUARTR       ; Point to 0.25
        CALL    ADDPHL          ; Add 0.25 to value
        POP     AF              ; Restore sign
        CALL    NC,INVSGN       ; Negative - Make positive
        ld      HL,SINTAB       ; Coefficient table
        JP      SUMSER          ; Evaluate sum of series

HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)

QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25

SINTAB: .BYTE   5                       ; Table used by SIN
        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
        .BYTE   064H,026H,099H,087H     ;-76.575
        .BYTE   058H,034H,023H,087H     ; 81.602
        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
        .BYTE   0DAH,00FH,049H,083H     ;  6.2832

TAN:    CALL    STAKFP          ; Put angle on stack
        CALL    SIN             ; Get SIN of angle
        POP     BC              ; Restore angle
        POP     HL
        CALL    STAKFP          ; Save SIN of angle
        EX      DE,HL           ; BCDE = Angle
        CALL    FPBCDE          ; Angle to FPREG
        CALL    COS             ; Get COS of angle
        JP      DIV             ; TAN = SIN / COS

ATN:    CALL    TSTSGN          ; Test sign of value
        CALL    M,NEGAFT        ; Negate result after if -ve
        CALL    M,INVSGN        ; Negate value if -ve
        ld      A,(FPEXP)       ; Get exponent
        CP      81H             ; Number less than 1?
        JP      C,ATN1          ; Yes - Get arc tangnt
        ld      BC,8100H        ; BCDE = 1
        ld      D,C
        ld      E,C
        CALL    DVBCDE          ; Get reciprocal of number
        ld      HL,SUBPHL       ; Sub angle from PI/2
        PUSH    HL              ; Save for angle > 1
ATN1:   ld      HL,ATNTAB       ; Coefficient table
        CALL    SUMSER          ; Evaluate sum of series
        ld      HL,HALFPI       ; PI/2 - angle in case > 1
        RET                     ; Number > 1 - Sub from PI/2

ATNTAB: .BYTE   9                       ; Table used by ATN
        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
        .BYTE   002H,06EH,084H,07BH     ;-1/15
        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
        .BYTE   074H,031H,09AH,07DH     ;-1/11
        .BYTE   084H,03DH,05AH,07DH     ; 1/9
        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
        .BYTE   000H,000H,000H,081H     ; 1/1


ARET:   RET                     ; A RETurn instruction

GETINP:
        ; JC REPLACING NEXT LINE:
;        RST	    10H             ;input a character
        CALL    chin   
        RET

CLS: 
        ld      A,CS            ; ASCII Clear screen
        JP      MONOUT          ; Output character

WIDTH:  CALL    GETINT          ; Get integer 0-255
        ld      A,E             ; Width to A
        ld      (LWIDTH),A      ; Set width
        RET

LINES:  CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        ld      (LINESC),DE     ; Set lines counter
        ld      (LINESN),DE     ; Set lines number
        RET

DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
        PUSH    DE              ; Save number
        POP     HL              ; Number to HL
        ld      B,(HL)          ; Get LSB of contents
        INC     HL
        ld      A,(HL)          ; Get MSB of contents
        JP      ABPASS          ; Return integer AB

DOKE:   CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        PUSH    DE              ; Save address
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        EX      (SP),HL         ; Save value,get address
        ld      (HL),E          ; Save LSB of value
        INC     HL
        ld      (HL),D          ; Save MSB of value
        POP     HL              ; Restore code string address
        RET


; HEX$(nn) Convert 16 bit number to Hexadecimal string

HEX: 	CALL	TSTNUM          ; Verify it's a number
        CALL	DEINT           ; Get integer -32768 to 32767
        PUSH	BC              ; Save contents of BC
        ld	    HL,PBUFF
        ld	    A,D             ; Get high order into A
        CP      $0
		JR      Z,HEX2          ; Skip output if both high digits are zero
        CALL    BYT2ASC         ; Convert D to ASCII
		ld      A,B
		CP      '0'
		JR      Z,HEX1          ; Don't store high digit if zero
        ld	    (HL),B          ; Store it to PBUFF
        INC	    HL              ; Next location
HEX1:   ld	    (HL),C          ; Store C to PBUFF+1
        INC     HL              ; Next location
HEX2:   ld	    A,E             ; Get lower byte
        CALL    BYT2ASC         ; Convert E to ASCII
		ld      A,D
        CP      $0
		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
		ld      A,B
		CP      '0'             ; If high digit of lower byte is zero then don't print
		JR      Z,HEX4
HEX3:   ld      (HL),B          ; to PBUFF+2
        INC     HL              ; Next location
HEX4:   ld      (HL),C          ; to PBUFF+3
        INC     HL              ; PBUFF+4 to zero
        XOR     A               ; Terminating character
        ld      (HL),A          ; Store zero to terminate
        INC     HL              ; Make sure PBUFF is terminated
        ld      (HL),A          ; Store the double zero there
        POP     BC              ; Get BC back
        ld      HL,PBUFF        ; Reset to start of PBUFF
        JP      STR1            ; Convert the PBUFF to a string and return it

BYT2ASC	ld      B,A             ; Save original value
        AND     $0F             ; Strip off upper nybble
        CP      $0A             ; 0-9?
        JR      C,ADD30         ; If A-F, add 7 more
        ADD     A,$07           ; Bring value up to ASCII A-F
ADD30	ADD     A,$30           ; And make ASCII
        ld      C,A             ; Save converted char to C
        ld      A,B             ; Retrieve original value
        RRCA                    ; and Rotate it right
        RRCA
        RRCA
        RRCA
        AND     $0F             ; Mask off upper nybble
        CP      $0A             ; 0-9? < A hex?
        JR      C,ADD301        ; Skip Add 7
        ADD     A,$07           ; Bring it up to ASCII A-F
ADD301	ADD     A,$30           ; And make it full ASCII
        ld      B,A             ; Store high order byte
        RET	

; Convert "&Hnnnn" to FPREG
; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
HEXTFP  EX      DE,HL           ; Move code string pointer to DE
        ld      HL,$0000        ; Zero out the value
        CALL    GETHEX          ; Check the number for valid hex
        JP      C,HXERR         ; First value wasn't hex, HX error
        JR      HEXLP1          ; Convert first character
HEXLP   CALL    GETHEX          ; Get second and addtional characters
        JR      C,HEXIT         ; Exit if not a hex character
HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL
        OR      L               ; Add in D0-D3 into L
        ld      L,A             ; Save new value
        JR      HEXLP           ; And continue until all hex characters are in

GETHEX  INC     DE              ; Next location
        ld      A,(DE)          ; Load character at pointer
        CP      ' '
        JP      Z,GETHEX        ; Skip spaces
        SUB     $30             ; Get absolute value
        RET     C               ; < "0", error
        CP      $0A
        JR      C,NOSUB7        ; Is already in the range 0-9
        SUB     $07             ; Reduce to A-F
        CP      $0A             ; Value should be $0A-$0F at this point
        RET     C               ; CY set if was :            ; < = > ? @
NOSUB7  CP      $10             ; > Greater than "F"?
        CCF
        RET                     ; CY set if it wasn't valid hex
    
HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
        ld      A,D             ; Load DE into AC
        ld      C,E             ; For prep to 
        PUSH    HL
        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
        POP     HL
        RET

HXERR:  ld      E,HX            ; ?HEX Error
        JP      ERROR

; BIN$(NN) Convert integer to a 1-16 char binary string
BIN:    CALL    TSTNUM          ; Verify it's a number
        CALL    DEINT           ; Get integer -32768 to 32767
BIN2:   PUSH    BC              ; Save contents of BC
        ld      HL,PBUFF
        ld      B,17            ; One higher than max char count
ZEROSUP:                        ; Suppress leading zeros
        DEC     B               ; Max 16 chars
        ld      A,B
        CP      $01
        JR      Z,BITOUT        ; Always output at least one character
        RL      E
        RL      D
        JR      NC,ZEROSUP
        JR      BITOUT2
BITOUT:      
        RL      E
        RL      D               ; Top bit now in carry
BITOUT2:
        ld      A,'0'           ; Char for '0'
        ADC     A,0             ; If carry set then '0' --> '1'
        ld      (HL),A
        INC     HL
        DEC     B
        JR      NZ,BITOUT
        XOR     A               ; Terminating character
        ld      (HL),A          ; Store zero to terminate
        INC     HL              ; Make sure PBUFF is terminated
        ld      (HL),A          ; Store the double zero there
        POP     BC
        ld      HL,PBUFF
        JP      STR1

; Convert "&Bnnnn" to FPREG
; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
BINTFP: EX      DE,HL           ; Move code string pointer to DE
        ld      HL,$0000        ; Zero out the value
        CALL    CHKBIN          ; Check the number for valid bin
        JP      C,BINERR        ; First value wasn't bin, HX error
BINIT:  SUB     '0'
        ADD     HL,HL           ; Rotate HL left
        OR      L
        ld      L,A
        CALL    CHKBIN          ; Get second and addtional characters
        JR      NC,BINIT        ; Process if a bin character
        EX      DE,HL           ; Value into DE, Code string into HL
        ld      A,D             ; Load DE into AC
        ld      C,E             ; For prep to 
        PUSH    HL
        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
        POP     HL
        RET

; Char is in A, NC if char is 0 or 1
CHKBIN: INC     DE
        ld      A,(DE)
        CP      ' '
        JP      Z,CHKBIN        ; Skip spaces
        CP      '0'             ; Set C if < '0'
        RET     C
        CP      '2'
        CCF                     ; Set C if > '1'
        RET

BINERR: ld      E,BN            ; ?BIN Error
        JP      ERROR


JJUMP1: 
        ld      IX,-1           ; Flag cold start
        JP      CSTART          ; Go and initialise

; JC DISABLING THIS.  THIS IS NOT MY MONOUT FUNCTION FOR THE BROTHER.
; See elsewhere for MONOUT.
;MONOUT: 
;        JP      $0008           ; output a char


MONITR: 
;        JP      $0000           ; Restart (Normally Monitor Start)
    ; JC CHANGING:
        jp apl_code_normal_start

INITST: ld      A,0             ; Clear break flag
        ld      (BRKFLG),A
        JP      INIT

ARETN:  RETN                    ; Return from NMI


TSTBIT: PUSH    AF              ; Save bit mask
        AND     B               ; Get common bits
        POP     BC              ; Restore bit mask
        CP      B               ; Same bit set?
        ld      A,0             ; Return 0 in A
        RET

OUTNCR: CALL    OUTC            ; Output character in A
        JP      PRNTCRLF        ; Output CRLF




;JC marking end of code region
ENDEND:
    db $00 ; String terminator 
.end




